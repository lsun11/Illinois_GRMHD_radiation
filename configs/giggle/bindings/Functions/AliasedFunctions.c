/*@@
   @file    AliasedFunctions.c
   @author  Automatically generated by CreateFunctionBindings.pl
   @desc
            Prototypes for the aliased functions.
   @enddesc
 @@*/


#include <stdlib.h>
#include <string.h>

#include "cctk_Flesh.h"
#include "cctk_WarnLevel.h"
#include "cctk_FortranString.h"

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_RegisterPhysicalBC_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_RegisterPhysicalBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_RegisterPhysicalBC (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_RegisterPhysicalBC (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_RegisterPhysicalBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_RegisterPhysicalBC has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_RegisterPhysicalBC_C_Wrapper)(GH , function_pointer , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_RegisterPhysicalBC) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_RegisterPhysicalBC) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_RegisterPhysicalBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_RegisterPhysicalBC has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_RegisterPhysicalBC_F_Wrapper)(GH , function_pointer , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_RegisterPhysicalBC(void);
CCTK_INT IsAliasedBoundary_RegisterPhysicalBC(void)
{
  return (Boundary_RegisterPhysicalBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_RegisterPhysicalBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_RegisterPhysicalBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_RegisterPhysicalBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_RegisterPhysicalBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_RegisterPhysicalBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_RegisterPhysicalBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_RegisterPhysicalBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_RegisterPhysicalBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectGroupForBC_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectGroupForBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectGroupForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name);
CCTK_INT Boundary_SelectGroupForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectGroupForBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBC has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectGroupForBC_C_Wrapper)(GH , faces , boundary_width , table_handle , var_name , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectGroupForBC) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectGroupForBC) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Boundary_SelectGroupForBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBC has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectGroupForBC_F_Wrapper)(GH , faces , boundary_width , table_handle , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectGroupForBC(void);
CCTK_INT IsAliasedBoundary_SelectGroupForBC(void)
{
  return (Boundary_SelectGroupForBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectGroupForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectGroupForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectGroupForBCI_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectGroupForBCI_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectGroupForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectGroupForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectGroupForBCI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBCI has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectGroupForBCI_C_Wrapper)(GH , faces , boundary_width , table_handle , group_index , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectGroupForBCI) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectGroupForBCI) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectGroupForBCI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBCI has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectGroupForBCI_F_Wrapper)(GH , faces , boundary_width , table_handle , group_index , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectGroupForBCI(void);
CCTK_INT IsAliasedBoundary_SelectGroupForBCI(void)
{
  return (Boundary_SelectGroupForBCI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectGroupForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBCI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectGroupForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBCI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectVarForBC_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectVarForBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectVarForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name);
CCTK_INT Boundary_SelectVarForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectVarForBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBC has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectVarForBC_C_Wrapper)(GH , faces , boundary_width , table_handle , var_name , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectVarForBC) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectVarForBC) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Boundary_SelectVarForBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBC has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectVarForBC_F_Wrapper)(GH , faces , boundary_width , table_handle , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectVarForBC(void);
CCTK_INT IsAliasedBoundary_SelectVarForBC(void)
{
  return (Boundary_SelectVarForBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectVarForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectVarForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectVarForBCI_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectVarForBCI_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectVarForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectVarForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectVarForBCI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBCI has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectVarForBCI_C_Wrapper)(GH , faces , boundary_width , table_handle , var_index , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectVarForBCI) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectVarForBCI) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectVarForBCI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBCI has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectVarForBCI_F_Wrapper)(GH , faces , boundary_width , table_handle , var_index , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectVarForBCI(void);
CCTK_INT IsAliasedBoundary_SelectVarForBCI(void)
{
  return (Boundary_SelectVarForBCI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectVarForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBCI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectVarForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBCI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectedGVs_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectedGVs_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectedGVs (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectedGVs (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectedGVs_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectedGVs has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectedGVs_C_Wrapper)(GH , array_size , var_indicies , faces , boundary_widths , table_handles , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectedGVs) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Boundary_SelectedGVs) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectedGVs_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectedGVs has not been provided by any thorn in your thornlist");
  }

  retval = (*Boundary_SelectedGVs_F_Wrapper)(GH , array_size , var_indicies , faces , boundary_widths , table_handles , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectedGVs(void);
CCTK_INT IsAliasedBoundary_SelectedGVs(void)
{
  return (Boundary_SelectedGVs_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectedGVs_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectedGVs_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectedGVs_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectedGVs_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectedGVs_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectedGVs_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectedGVs_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectedGVs_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Carpet_Regrid_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force) = NULL;
static CCTK_INT (*Carpet_Regrid_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Carpet_Regrid (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force);
CCTK_INT Carpet_Regrid (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force)
{
  CCTK_INT retval;

  if (!Carpet_Regrid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Carpet_Regrid has not been provided by any thorn in your thornlist");
  }

  retval = (*Carpet_Regrid_C_Wrapper)(cctkGH , superregss , regsss , force);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Carpet_Regrid) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force);
CCTK_INT CCTK_FCALL CCTK_FNAME(Carpet_Regrid) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force)
{
  CCTK_INT retval;

  if (!Carpet_Regrid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Carpet_Regrid has not been provided by any thorn in your thornlist");
  }

  retval = (*Carpet_Regrid_F_Wrapper)(cctkGH , superregss , regsss , force);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCarpet_Regrid(void);
CCTK_INT IsAliasedCarpet_Regrid(void)
{
  return (Carpet_Regrid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCarpet_Regrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force));
CCTK_INT AliasCarpet_Regrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregss ,
 const CCTK_POINTER regsss ,
 const CCTK_INT force))
{
  CCTK_INT aliased = Carpet_Regrid_C_Wrapper != NULL;
  if (!aliased)
  {
    Carpet_Regrid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCarpet_Regrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force));
CCTK_INT AliasCarpet_Regrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregss ,
 const CCTK_POINTER* regsss ,
 const CCTK_INT* force))
{
  CCTK_INT aliased = Carpet_Regrid_C_Wrapper != NULL;
  if (!aliased)
  {
    Carpet_Regrid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Carpet_RegridMaps_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force) = NULL;
static CCTK_INT (*Carpet_RegridMaps_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Carpet_RegridMaps (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force);
CCTK_INT Carpet_RegridMaps (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force)
{
  CCTK_INT retval;

  if (!Carpet_RegridMaps_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Carpet_RegridMaps has not been provided by any thorn in your thornlist");
  }

  retval = (*Carpet_RegridMaps_C_Wrapper)(cctkGH , superregsss , regssss , force);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Carpet_RegridMaps) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force);
CCTK_INT CCTK_FCALL CCTK_FNAME(Carpet_RegridMaps) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force)
{
  CCTK_INT retval;

  if (!Carpet_RegridMaps_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Carpet_RegridMaps has not been provided by any thorn in your thornlist");
  }

  retval = (*Carpet_RegridMaps_F_Wrapper)(cctkGH , superregsss , regssss , force);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCarpet_RegridMaps(void);
CCTK_INT IsAliasedCarpet_RegridMaps(void)
{
  return (Carpet_RegridMaps_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCarpet_RegridMaps_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force));
CCTK_INT AliasCarpet_RegridMaps_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER superregsss ,
 const CCTK_POINTER regssss ,
 const CCTK_INT force))
{
  CCTK_INT aliased = Carpet_RegridMaps_C_Wrapper != NULL;
  if (!aliased)
  {
    Carpet_RegridMaps_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCarpet_RegridMaps_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force));
CCTK_INT AliasCarpet_RegridMaps_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* superregsss ,
 const CCTK_POINTER* regssss ,
 const CCTK_INT* force))
{
  CCTK_INT aliased = Carpet_RegridMaps_C_Wrapper != NULL;
  if (!aliased)
  {
    Carpet_RegridMaps_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*CheckVarsForNaN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found) = NULL;
static CCTK_INT (*CheckVarsForNaN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT CheckVarsForNaN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found);
CCTK_INT CheckVarsForNaN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found)
{
  CCTK_INT retval;

  if (!CheckVarsForNaN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CheckVarsForNaN has not been provided by any thorn in your thornlist");
  }

  retval = (*CheckVarsForNaN_C_Wrapper)(cctkGH , report_max , vars , check_for , action_if_found);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(CheckVarsForNaN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 THREE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(CheckVarsForNaN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 THREE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  THREE_FORTSTRING_CREATE(cctki_string1,cctki_string2,cctki_string3)

  if (!CheckVarsForNaN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CheckVarsForNaN has not been provided by any thorn in your thornlist");
  }

  retval = (*CheckVarsForNaN_F_Wrapper)(cctkGH , report_max , cctki_string1,cctki_string2,cctki_string3);
  free(cctki_string1);
  free(cctki_string2);
  free(cctki_string3);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCheckVarsForNaN(void);
CCTK_INT IsAliasedCheckVarsForNaN(void)
{
  return (CheckVarsForNaN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCheckVarsForNaN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found));
CCTK_INT AliasCheckVarsForNaN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found))
{
  CCTK_INT aliased = CheckVarsForNaN_C_Wrapper != NULL;
  if (!aliased)
  {
    CheckVarsForNaN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCheckVarsForNaN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found));
CCTK_INT AliasCheckVarsForNaN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found))
{
  CCTK_INT aliased = CheckVarsForNaN_C_Wrapper != NULL;
  if (!aliased)
  {
    CheckVarsForNaN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*ConfToPhysInPlace_C_Wrapper) (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;
static void (*ConfToPhysInPlace_F_Wrapper) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void ConfToPhysInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void ConfToPhysInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!ConfToPhysInPlace_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConfToPhysInPlace has not been provided by any thorn in your thornlist");
  }

  (*ConfToPhysInPlace_C_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

void CCTK_FCALL CCTK_FNAME(ConfToPhysInPlace) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void CCTK_FCALL CCTK_FNAME(ConfToPhysInPlace) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!ConfToPhysInPlace_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConfToPhysInPlace has not been provided by any thorn in your thornlist");
  }

  (*ConfToPhysInPlace_F_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConfToPhysInPlace(void);
CCTK_INT IsAliasedConfToPhysInPlace(void)
{
  return (ConfToPhysInPlace_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConfToPhysInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasConfToPhysInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = ConfToPhysInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    ConfToPhysInPlace_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConfToPhysInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasConfToPhysInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = ConfToPhysInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    ConfToPhysInPlace_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromExteriorBoundary_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromExteriorBoundary_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromExteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromExteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromExteriorBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromExteriorBoundary has not been provided by any thorn in your thornlist");
  }

  retval = (*ConvertFromExteriorBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromExteriorBoundary) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromExteriorBoundary) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromExteriorBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromExteriorBoundary has not been provided by any thorn in your thornlist");
  }

  retval = (*ConvertFromExteriorBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromExteriorBoundary(void);
CCTK_INT IsAliasedConvertFromExteriorBoundary(void)
{
  return (ConvertFromExteriorBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromExteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromExteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromExteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromExteriorBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromExteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromExteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromExteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromExteriorBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromInteriorBoundary_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromInteriorBoundary_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromInteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromInteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromInteriorBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromInteriorBoundary has not been provided by any thorn in your thornlist");
  }

  retval = (*ConvertFromInteriorBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromInteriorBoundary) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromInteriorBoundary) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromInteriorBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromInteriorBoundary has not been provided by any thorn in your thornlist");
  }

  retval = (*ConvertFromInteriorBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromInteriorBoundary(void);
CCTK_INT IsAliasedConvertFromInteriorBoundary(void)
{
  return (ConvertFromInteriorBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromInteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromInteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromInteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromInteriorBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromInteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromInteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromInteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromInteriorBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromPhysicalBoundary_C_Wrapper) (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromPhysicalBoundary_F_Wrapper) (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromPhysicalBoundary (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromPhysicalBoundary (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromPhysicalBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromPhysicalBoundary has not been provided by any thorn in your thornlist");
  }

  retval = (*ConvertFromPhysicalBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromPhysicalBoundary) (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(ConvertFromPhysicalBoundary) (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromPhysicalBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromPhysicalBoundary has not been provided by any thorn in your thornlist");
  }

  retval = (*ConvertFromPhysicalBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromPhysicalBoundary(void);
CCTK_INT IsAliasedConvertFromPhysicalBoundary(void)
{
  return (ConvertFromPhysicalBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromPhysicalBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromPhysicalBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_CoordHandle_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_CoordHandle_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_CoordHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname);
CCTK_INT Coord_CoordHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_CoordHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordHandle has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_CoordHandle_C_Wrapper)(GH , coordname , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_CoordHandle) (const CCTK_POINTER_TO_CONST* GH ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_CoordHandle) (const CCTK_POINTER_TO_CONST* GH ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

  TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Coord_CoordHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordHandle has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_CoordHandle_F_Wrapper)(GH , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_CoordHandle(void);
CCTK_INT IsAliasedCoord_CoordHandle(void)
{
  return (Coord_CoordHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_CoordHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname));
CCTK_INT AliasCoord_CoordHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_CoordHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_CoordHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname));
CCTK_INT AliasCoord_CoordHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_CoordHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_CoordRegister_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname) = NULL;
static CCTK_INT (*Coord_CoordRegister_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_CoordRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname);
CCTK_INT Coord_CoordRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname)
{
  CCTK_INT retval;

  if (!Coord_CoordRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordRegister has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_CoordRegister_C_Wrapper)(GH , systemhandle , direction , coordname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_CoordRegister) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_CoordRegister) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_CoordRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordRegister has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_CoordRegister_F_Wrapper)(GH , systemhandle , direction , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_CoordRegister(void);
CCTK_INT IsAliasedCoord_CoordRegister(void)
{
  return (Coord_CoordRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_CoordRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname));
CCTK_INT AliasCoord_CoordRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname))
{
  CCTK_INT aliased = Coord_CoordRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_CoordRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname));
CCTK_INT AliasCoord_CoordRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname))
{
  CCTK_INT aliased = Coord_CoordRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_GetDefaultSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim) = NULL;
static CCTK_INT (*Coord_GetDefaultSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_GetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim);
CCTK_INT Coord_GetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim)
{
  CCTK_INT retval;

  if (!Coord_GetDefaultSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GetDefaultSystem has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_GetDefaultSystem_C_Wrapper)(GH , systemdim);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_GetDefaultSystem) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_GetDefaultSystem) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim)
{
  CCTK_INT retval;

  if (!Coord_GetDefaultSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GetDefaultSystem has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_GetDefaultSystem_F_Wrapper)(GH , systemdim);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_GetDefaultSystem(void);
CCTK_INT IsAliasedCoord_GetDefaultSystem(void)
{
  return (Coord_GetDefaultSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_GetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim));
CCTK_INT AliasCoord_GetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim))
{
  CCTK_INT aliased = Coord_GetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GetDefaultSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_GetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim));
CCTK_INT AliasCoord_GetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim))
{
  CCTK_INT aliased = Coord_GetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GetDefaultSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_GroupSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname) = NULL;
static CCTK_INT (*Coord_GroupSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_GroupSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname);
CCTK_INT Coord_GroupSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname)
{
  CCTK_INT retval;

  if (!Coord_GroupSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GroupSystem has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_GroupSystem_C_Wrapper)(GH , groupname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_GroupSystem) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_GroupSystem) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_GroupSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GroupSystem has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_GroupSystem_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_GroupSystem(void);
CCTK_INT IsAliasedCoord_GroupSystem(void)
{
  return (Coord_GroupSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_GroupSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname));
CCTK_INT AliasCoord_GroupSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname))
{
  CCTK_INT aliased = Coord_GroupSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GroupSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_GroupSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname));
CCTK_INT AliasCoord_GroupSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname))
{
  CCTK_INT aliased = Coord_GroupSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GroupSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SetDefaultSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SetDefaultSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname);
CCTK_INT Coord_SetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SetDefaultSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SetDefaultSystem has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_SetDefaultSystem_C_Wrapper)(GH , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SetDefaultSystem) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SetDefaultSystem) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SetDefaultSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SetDefaultSystem has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_SetDefaultSystem_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SetDefaultSystem(void);
CCTK_INT IsAliasedCoord_SetDefaultSystem(void)
{
  return (Coord_SetDefaultSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SetDefaultSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SetDefaultSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SystemHandle_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SystemHandle_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SystemHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname);
CCTK_INT Coord_SystemHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SystemHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemHandle has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_SystemHandle_C_Wrapper)(GH , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SystemHandle) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SystemHandle) (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SystemHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemHandle has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_SystemHandle_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SystemHandle(void);
CCTK_INT IsAliasedCoord_SystemHandle(void)
{
  return (Coord_SystemHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SystemHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SystemHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SystemRegister_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SystemRegister_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SystemRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname);
CCTK_INT Coord_SystemRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SystemRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemRegister has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_SystemRegister_C_Wrapper)(GH , dim , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SystemRegister) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(Coord_SystemRegister) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SystemRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemRegister has not been provided by any thorn in your thornlist");
  }

  retval = (*Coord_SystemRegister_F_Wrapper)(GH , dim , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SystemRegister(void);
CCTK_INT IsAliasedCoord_SystemRegister(void)
{
  return (Coord_SystemRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SystemRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SystemRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*DriverInterpolate_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;
static CCTK_INT (*DriverInterpolate_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT DriverInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT DriverInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!DriverInterpolate_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function DriverInterpolate has not been provided by any thorn in your thornlist");
  }

  retval = (*DriverInterpolate_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(DriverInterpolate) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL CCTK_FNAME(DriverInterpolate) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!DriverInterpolate_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function DriverInterpolate has not been provided by any thorn in your thornlist");
  }

  retval = (*DriverInterpolate_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDriverInterpolate(void);
CCTK_INT IsAliasedDriverInterpolate(void)
{
  return (DriverInterpolate_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDriverInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasDriverInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = DriverInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    DriverInterpolate_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDriverInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasDriverInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = DriverInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    DriverInterpolate_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*EnableProlongating_C_Wrapper) (const CCTK_INT Status) = NULL;
static CCTK_INT (*EnableProlongating_F_Wrapper) (const CCTK_INT* Status) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT EnableProlongating (const CCTK_INT Status);
CCTK_INT EnableProlongating (const CCTK_INT Status)
{
  CCTK_INT retval;

  if (!EnableProlongating_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EnableProlongating has not been provided by any thorn in your thornlist");
  }

  retval = (*EnableProlongating_C_Wrapper)(Status);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(EnableProlongating) (const CCTK_INT* Status);
CCTK_INT CCTK_FCALL CCTK_FNAME(EnableProlongating) (const CCTK_INT* Status)
{
  CCTK_INT retval;

  if (!EnableProlongating_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EnableProlongating has not been provided by any thorn in your thornlist");
  }

  retval = (*EnableProlongating_F_Wrapper)(Status);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEnableProlongating(void);
CCTK_INT IsAliasedEnableProlongating(void)
{
  return (EnableProlongating_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEnableProlongating_C(CCTK_INT (*func)(const CCTK_INT Status));
CCTK_INT AliasEnableProlongating_C(CCTK_INT (*func)(const CCTK_INT Status))
{
  CCTK_INT aliased = EnableProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    EnableProlongating_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEnableProlongating_F(CCTK_INT (*func)(const CCTK_INT* Status));
CCTK_INT AliasEnableProlongating_F(CCTK_INT (*func)(const CCTK_INT* Status))
{
  CCTK_INT aliased = EnableProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    EnableProlongating_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetBoundarySpecification_C_Wrapper) (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;
static CCTK_INT (*GetBoundarySpecification_F_Wrapper) (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetBoundarySpecification (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT GetBoundarySpecification (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!GetBoundarySpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*GetBoundarySpecification_C_Wrapper)(size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetBoundarySpecification) (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetBoundarySpecification) (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!GetBoundarySpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*GetBoundarySpecification_F_Wrapper)(size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetBoundarySpecification(void);
CCTK_INT IsAliasedGetBoundarySpecification(void)
{
  return (GetBoundarySpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasGetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasGetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetCoordRange_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta) = NULL;
static CCTK_INT (*GetCoordRange_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetCoordRange (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta);
CCTK_INT GetCoordRange (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta)
{
  CCTK_INT retval;

  if (!GetCoordRange_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetCoordRange has not been provided by any thorn in your thornlist");
  }

  retval = (*GetCoordRange_C_Wrapper)(cctkGH , m , ml , size , gsh , lower , upper , delta);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetCoordRange) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetCoordRange) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta)
{
  CCTK_INT retval;

  if (!GetCoordRange_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetCoordRange has not been provided by any thorn in your thornlist");
  }

  retval = (*GetCoordRange_F_Wrapper)(cctkGH , m , ml , size , gsh , lower , upper , delta);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetCoordRange(void);
CCTK_INT IsAliasedGetCoordRange(void)
{
  return (GetCoordRange_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetCoordRange_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta));
CCTK_INT AliasGetCoordRange_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT m ,
 const CCTK_INT ml ,
 const CCTK_INT size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta))
{
  CCTK_INT aliased = GetCoordRange_C_Wrapper != NULL;
  if (!aliased)
  {
    GetCoordRange_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetCoordRange_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta));
CCTK_INT AliasGetCoordRange_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* m ,
 const CCTK_INT* ml ,
 const CCTK_INT* size ,
 CCTK_INT* gsh ,
 CCTK_REAL* lower ,
 CCTK_REAL* upper ,
 CCTK_REAL* delta))
{
  CCTK_INT aliased = GetCoordRange_C_Wrapper != NULL;
  if (!aliased)
  {
    GetCoordRange_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetDomainSpecification_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;
static CCTK_INT (*GetDomainSpecification_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetDomainSpecification (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT GetDomainSpecification (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!GetDomainSpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetDomainSpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*GetDomainSpecification_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetDomainSpecification) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetDomainSpecification) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!GetDomainSpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetDomainSpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*GetDomainSpecification_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetDomainSpecification(void);
CCTK_INT IsAliasedGetDomainSpecification(void)
{
  return (GetDomainSpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasGetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetDomainSpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasGetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetDomainSpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetLocalComponents_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetLocalComponents_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetLocalComponents (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetLocalComponents (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetLocalComponents_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetLocalComponents has not been provided by any thorn in your thornlist");
  }

  retval = (*GetLocalComponents_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetLocalComponents) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetLocalComponents) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetLocalComponents_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetLocalComponents has not been provided by any thorn in your thornlist");
  }

  retval = (*GetLocalComponents_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetLocalComponents(void);
CCTK_INT IsAliasedGetLocalComponents(void)
{
  return (GetLocalComponents_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetLocalComponents_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetLocalComponents_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetLocalComponents_C_Wrapper != NULL;
  if (!aliased)
  {
    GetLocalComponents_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetLocalComponents_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetLocalComponents_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetLocalComponents_C_Wrapper != NULL;
  if (!aliased)
  {
    GetLocalComponents_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*GetMPICommUniverse_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*GetMPICommUniverse_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST GetMPICommUniverse (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST GetMPICommUniverse (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!GetMPICommUniverse_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPICommUniverse has not been provided by any thorn in your thornlist");
  }

  retval = (*GetMPICommUniverse_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(GetMPICommUniverse) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(GetMPICommUniverse) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!GetMPICommUniverse_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPICommUniverse has not been provided by any thorn in your thornlist");
  }

  retval = (*GetMPICommUniverse_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMPICommUniverse(void);
CCTK_INT IsAliasedGetMPICommUniverse(void)
{
  return (GetMPICommUniverse_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMPICommUniverse_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetMPICommUniverse_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetMPICommUniverse_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPICommUniverse_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMPICommUniverse_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetMPICommUniverse_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetMPICommUniverse_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPICommUniverse_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*GetMPICommWorld_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*GetMPICommWorld_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST GetMPICommWorld (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST GetMPICommWorld (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!GetMPICommWorld_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPICommWorld has not been provided by any thorn in your thornlist");
  }

  retval = (*GetMPICommWorld_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(GetMPICommWorld) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(GetMPICommWorld) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!GetMPICommWorld_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetMPICommWorld has not been provided by any thorn in your thornlist");
  }

  retval = (*GetMPICommWorld_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetMPICommWorld(void);
CCTK_INT IsAliasedGetMPICommWorld(void)
{
  return (GetMPICommWorld_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetMPICommWorld_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetMPICommWorld_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetMPICommWorld_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPICommWorld_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetMPICommWorld_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetMPICommWorld_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetMPICommWorld_C_Wrapper != NULL;
  if (!aliased)
  {
    GetMPICommWorld_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetRefinementLevel_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetRefinementLevel_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetRefinementLevel (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetRefinementLevel (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetRefinementLevel_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRefinementLevel has not been provided by any thorn in your thornlist");
  }

  retval = (*GetRefinementLevel_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetRefinementLevel) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetRefinementLevel) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetRefinementLevel_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRefinementLevel has not been provided by any thorn in your thornlist");
  }

  retval = (*GetRefinementLevel_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetRefinementLevel(void);
CCTK_INT IsAliasedGetRefinementLevel(void)
{
  return (GetRefinementLevel_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetRefinementLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetRefinementLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetRefinementLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRefinementLevel_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetRefinementLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetRefinementLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetRefinementLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRefinementLevel_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetRefinementLevels_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*GetRefinementLevels_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetRefinementLevels (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT GetRefinementLevels (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!GetRefinementLevels_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRefinementLevels has not been provided by any thorn in your thornlist");
  }

  retval = (*GetRefinementLevels_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetRefinementLevels) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetRefinementLevels) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!GetRefinementLevels_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetRefinementLevels has not been provided by any thorn in your thornlist");
  }

  retval = (*GetRefinementLevels_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetRefinementLevels(void);
CCTK_INT IsAliasedGetRefinementLevels(void)
{
  return (GetRefinementLevels_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetRefinementLevels_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasGetRefinementLevels_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = GetRefinementLevels_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRefinementLevels_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetRefinementLevels_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasGetRefinementLevels_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = GetRefinementLevels_C_Wrapper != NULL;
  if (!aliased)
  {
    GetRefinementLevels_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetSymmetryBoundaries_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd) = NULL;
static CCTK_INT (*GetSymmetryBoundaries_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetSymmetryBoundaries (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd);
CCTK_INT GetSymmetryBoundaries (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd)
{
  CCTK_INT retval;

  if (!GetSymmetryBoundaries_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetSymmetryBoundaries has not been provided by any thorn in your thornlist");
  }

  retval = (*GetSymmetryBoundaries_C_Wrapper)(cctkGH , size , symbnd);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(GetSymmetryBoundaries) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd);
CCTK_INT CCTK_FCALL CCTK_FNAME(GetSymmetryBoundaries) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd)
{
  CCTK_INT retval;

  if (!GetSymmetryBoundaries_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetSymmetryBoundaries has not been provided by any thorn in your thornlist");
  }

  retval = (*GetSymmetryBoundaries_F_Wrapper)(cctkGH , size , symbnd);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetSymmetryBoundaries(void);
CCTK_INT IsAliasedGetSymmetryBoundaries(void)
{
  return (GetSymmetryBoundaries_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetSymmetryBoundaries_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd));
CCTK_INT AliasGetSymmetryBoundaries_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd))
{
  CCTK_INT aliased = GetSymmetryBoundaries_C_Wrapper != NULL;
  if (!aliased)
  {
    GetSymmetryBoundaries_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetSymmetryBoundaries_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd));
CCTK_INT AliasGetSymmetryBoundaries_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd))
{
  CCTK_INT aliased = GetSymmetryBoundaries_C_Wrapper != NULL;
  if (!aliased)
  {
    GetSymmetryBoundaries_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*HorizonCentroid_C_Wrapper) (const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z) = NULL;
static CCTK_INT (*HorizonCentroid_F_Wrapper) (const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT HorizonCentroid (const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z);
CCTK_INT HorizonCentroid (const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z)
{
  CCTK_INT retval;

  if (!HorizonCentroid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonCentroid has not been provided by any thorn in your thornlist");
  }

  retval = (*HorizonCentroid_C_Wrapper)(horizon_number , centroid_x , centroid_y , centroid_z);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonCentroid) (const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z);
CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonCentroid) (const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z)
{
  CCTK_INT retval;

  if (!HorizonCentroid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonCentroid has not been provided by any thorn in your thornlist");
  }

  retval = (*HorizonCentroid_F_Wrapper)(horizon_number , centroid_x , centroid_y , centroid_z);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHorizonCentroid(void);
CCTK_INT IsAliasedHorizonCentroid(void)
{
  return (HorizonCentroid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHorizonCentroid_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z));
CCTK_INT AliasHorizonCentroid_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z))
{
  CCTK_INT aliased = HorizonCentroid_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonCentroid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHorizonCentroid_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z));
CCTK_INT AliasHorizonCentroid_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 CCTK_REAL* centroid_x ,
 CCTK_REAL* centroid_y ,
 CCTK_REAL* centroid_z))
{
  CCTK_INT aliased = HorizonCentroid_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonCentroid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*HorizonLocalCoordinateOrigin_C_Wrapper) (const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z) = NULL;
static CCTK_INT (*HorizonLocalCoordinateOrigin_F_Wrapper) (const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT HorizonLocalCoordinateOrigin (const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z);
CCTK_INT HorizonLocalCoordinateOrigin (const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z)
{
  CCTK_INT retval;

  if (!HorizonLocalCoordinateOrigin_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonLocalCoordinateOrigin has not been provided by any thorn in your thornlist");
  }

  retval = (*HorizonLocalCoordinateOrigin_C_Wrapper)(horizon_number , origin_x , origin_y , origin_z);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonLocalCoordinateOrigin) (const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z);
CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonLocalCoordinateOrigin) (const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z)
{
  CCTK_INT retval;

  if (!HorizonLocalCoordinateOrigin_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonLocalCoordinateOrigin has not been provided by any thorn in your thornlist");
  }

  retval = (*HorizonLocalCoordinateOrigin_F_Wrapper)(horizon_number , origin_x , origin_y , origin_z);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHorizonLocalCoordinateOrigin(void);
CCTK_INT IsAliasedHorizonLocalCoordinateOrigin(void)
{
  return (HorizonLocalCoordinateOrigin_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHorizonLocalCoordinateOrigin_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z));
CCTK_INT AliasHorizonLocalCoordinateOrigin_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z))
{
  CCTK_INT aliased = HorizonLocalCoordinateOrigin_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonLocalCoordinateOrigin_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHorizonLocalCoordinateOrigin_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z));
CCTK_INT AliasHorizonLocalCoordinateOrigin_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 CCTK_REAL* origin_x ,
 CCTK_REAL* origin_y ,
 CCTK_REAL* origin_z))
{
  CCTK_INT aliased = HorizonLocalCoordinateOrigin_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonLocalCoordinateOrigin_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*HorizonRadiusInDirection_C_Wrapper) (const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius) = NULL;
static CCTK_INT (*HorizonRadiusInDirection_F_Wrapper) (const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT HorizonRadiusInDirection (const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius);
CCTK_INT HorizonRadiusInDirection (const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius)
{
  CCTK_INT retval;

  if (!HorizonRadiusInDirection_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonRadiusInDirection has not been provided by any thorn in your thornlist");
  }

  retval = (*HorizonRadiusInDirection_C_Wrapper)(horizon_number , N_points , x , y , z , radius);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonRadiusInDirection) (const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius);
CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonRadiusInDirection) (const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius)
{
  CCTK_INT retval;

  if (!HorizonRadiusInDirection_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonRadiusInDirection has not been provided by any thorn in your thornlist");
  }

  retval = (*HorizonRadiusInDirection_F_Wrapper)(horizon_number , N_points , x , y , z , radius);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHorizonRadiusInDirection(void);
CCTK_INT IsAliasedHorizonRadiusInDirection(void)
{
  return (HorizonRadiusInDirection_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHorizonRadiusInDirection_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius));
CCTK_INT AliasHorizonRadiusInDirection_C(CCTK_INT (*func)(const CCTK_INT horizon_number ,
 const CCTK_INT N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius))
{
  CCTK_INT aliased = HorizonRadiusInDirection_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonRadiusInDirection_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHorizonRadiusInDirection_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius));
CCTK_INT AliasHorizonRadiusInDirection_F(CCTK_INT (*func)(const CCTK_INT* horizon_number ,
 const CCTK_INT* N_points ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z ,
 CCTK_REAL* radius))
{
  CCTK_INT aliased = HorizonRadiusInDirection_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonRadiusInDirection_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*HorizonWasFound_C_Wrapper) (const CCTK_INT horizon_number) = NULL;
static CCTK_INT (*HorizonWasFound_F_Wrapper) (const CCTK_INT* horizon_number) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT HorizonWasFound (const CCTK_INT horizon_number);
CCTK_INT HorizonWasFound (const CCTK_INT horizon_number)
{
  CCTK_INT retval;

  if (!HorizonWasFound_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonWasFound has not been provided by any thorn in your thornlist");
  }

  retval = (*HorizonWasFound_C_Wrapper)(horizon_number);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonWasFound) (const CCTK_INT* horizon_number);
CCTK_INT CCTK_FCALL CCTK_FNAME(HorizonWasFound) (const CCTK_INT* horizon_number)
{
  CCTK_INT retval;

  if (!HorizonWasFound_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function HorizonWasFound has not been provided by any thorn in your thornlist");
  }

  retval = (*HorizonWasFound_F_Wrapper)(horizon_number);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHorizonWasFound(void);
CCTK_INT IsAliasedHorizonWasFound(void)
{
  return (HorizonWasFound_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHorizonWasFound_C(CCTK_INT (*func)(const CCTK_INT horizon_number));
CCTK_INT AliasHorizonWasFound_C(CCTK_INT (*func)(const CCTK_INT horizon_number))
{
  CCTK_INT aliased = HorizonWasFound_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonWasFound_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHorizonWasFound_F(CCTK_INT (*func)(const CCTK_INT* horizon_number));
CCTK_INT AliasHorizonWasFound_F(CCTK_INT (*func)(const CCTK_INT* horizon_number))
{
  CCTK_INT aliased = HorizonWasFound_C_Wrapper != NULL;
  if (!aliased)
  {
    HorizonWasFound_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_FreeMapping_C_Wrapper) (const CCTK_INT mapping_handle) = NULL;
static CCTK_INT (*Hyperslab_FreeMapping_F_Wrapper) (const CCTK_INT* mapping_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_FreeMapping (const CCTK_INT mapping_handle);
CCTK_INT Hyperslab_FreeMapping (const CCTK_INT mapping_handle)
{
  CCTK_INT retval;

  if (!Hyperslab_FreeMapping_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_FreeMapping has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_FreeMapping_C_Wrapper)(mapping_handle);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_FreeMapping) (const CCTK_INT* mapping_handle);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_FreeMapping) (const CCTK_INT* mapping_handle)
{
  CCTK_INT retval;

  if (!Hyperslab_FreeMapping_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_FreeMapping has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_FreeMapping_F_Wrapper)(mapping_handle);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_FreeMapping(void);
CCTK_INT IsAliasedHyperslab_FreeMapping(void)
{
  return (Hyperslab_FreeMapping_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_FreeMapping_C(CCTK_INT (*func)(const CCTK_INT mapping_handle));
CCTK_INT AliasHyperslab_FreeMapping_C(CCTK_INT (*func)(const CCTK_INT mapping_handle))
{
  CCTK_INT aliased = Hyperslab_FreeMapping_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_FreeMapping_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_FreeMapping_F(CCTK_INT (*func)(const CCTK_INT* mapping_handle));
CCTK_INT AliasHyperslab_FreeMapping_F(CCTK_INT (*func)(const CCTK_INT* mapping_handle))
{
  CCTK_INT aliased = Hyperslab_FreeMapping_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_FreeMapping_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_Get_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata) = NULL;
static CCTK_INT (*Hyperslab_Get_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_Get (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata);
CCTK_INT Hyperslab_Get (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata)
{
  CCTK_INT retval;

  if (!Hyperslab_Get_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_Get has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_Get_C_Wrapper)(cctkGH , mapping_handle , proc , vindex , timelevel , hdatatype , hdata);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_Get) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_Get) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata)
{
  CCTK_INT retval;

  if (!Hyperslab_Get_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_Get has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_Get_F_Wrapper)(cctkGH , mapping_handle , proc , vindex , timelevel , hdatatype , hdata);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_Get(void);
CCTK_INT IsAliasedHyperslab_Get(void)
{
  return (Hyperslab_Get_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_Get_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata));
CCTK_INT AliasHyperslab_Get_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata))
{
  CCTK_INT aliased = Hyperslab_Get_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_Get_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_Get_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata));
CCTK_INT AliasHyperslab_Get_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata))
{
  CCTK_INT aliased = Hyperslab_Get_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_Get_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_GetList_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals) = NULL;
static CCTK_INT (*Hyperslab_GetList_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_GetList (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals);
CCTK_INT Hyperslab_GetList (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals)
{
  CCTK_INT retval;

  if (!Hyperslab_GetList_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GetList has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_GetList_C_Wrapper)(cctkGH , mapping_handle , num_arrays , procs , vindices , timelevels , hdatatypes , hdata , retvals);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_GetList) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_GetList) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals)
{
  CCTK_INT retval;

  if (!Hyperslab_GetList_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GetList has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_GetList_F_Wrapper)(cctkGH , mapping_handle , num_arrays , procs , vindices , timelevels , hdatatypes , hdata , retvals);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_GetList(void);
CCTK_INT IsAliasedHyperslab_GetList(void)
{
  return (Hyperslab_GetList_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_GetList_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals));
CCTK_INT AliasHyperslab_GetList_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals))
{
  CCTK_INT aliased = Hyperslab_GetList_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GetList_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_GetList_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals));
CCTK_INT AliasHyperslab_GetList_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals))
{
  CCTK_INT aliased = Hyperslab_GetList_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GetList_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_GlobalMappingByIndex_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize) = NULL;
static CCTK_INT (*Hyperslab_GlobalMappingByIndex_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_GlobalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize);
CCTK_INT Hyperslab_GlobalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize)
{
  CCTK_INT retval;

  if (!Hyperslab_GlobalMappingByIndex_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GlobalMappingByIndex has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_GlobalMappingByIndex_C_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_GlobalMappingByIndex) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_GlobalMappingByIndex) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize)
{
  CCTK_INT retval;

  if (!Hyperslab_GlobalMappingByIndex_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GlobalMappingByIndex has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_GlobalMappingByIndex_F_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_GlobalMappingByIndex(void);
CCTK_INT IsAliasedHyperslab_GlobalMappingByIndex(void)
{
  return (Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_GlobalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize));
CCTK_INT AliasHyperslab_GlobalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize))
{
  CCTK_INT aliased = Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GlobalMappingByIndex_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_GlobalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize));
CCTK_INT AliasHyperslab_GlobalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize))
{
  CCTK_INT aliased = Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GlobalMappingByIndex_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_LocalMappingByIndex_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global) = NULL;
static CCTK_INT (*Hyperslab_LocalMappingByIndex_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_LocalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global);
CCTK_INT Hyperslab_LocalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global)
{
  CCTK_INT retval;

  if (!Hyperslab_LocalMappingByIndex_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_LocalMappingByIndex has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_LocalMappingByIndex_C_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize_local , hsize_global , hoffset_global);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_LocalMappingByIndex) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global);
CCTK_INT CCTK_FCALL CCTK_FNAME(Hyperslab_LocalMappingByIndex) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global)
{
  CCTK_INT retval;

  if (!Hyperslab_LocalMappingByIndex_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_LocalMappingByIndex has not been provided by any thorn in your thornlist");
  }

  retval = (*Hyperslab_LocalMappingByIndex_F_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize_local , hsize_global , hoffset_global);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_LocalMappingByIndex(void);
CCTK_INT IsAliasedHyperslab_LocalMappingByIndex(void)
{
  return (Hyperslab_LocalMappingByIndex_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_LocalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global));
CCTK_INT AliasHyperslab_LocalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global))
{
  CCTK_INT aliased = Hyperslab_LocalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_LocalMappingByIndex_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_LocalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global));
CCTK_INT AliasHyperslab_LocalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global))
{
  CCTK_INT aliased = Hyperslab_LocalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_LocalMappingByIndex_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*IO_TruncateOutputFiles_C_Wrapper) (const CCTK_POINTER_TO_CONST GH) = NULL;
static CCTK_INT (*IO_TruncateOutputFiles_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT IO_TruncateOutputFiles (const CCTK_POINTER_TO_CONST GH);
CCTK_INT IO_TruncateOutputFiles (const CCTK_POINTER_TO_CONST GH)
{
  CCTK_INT retval;

  if (!IO_TruncateOutputFiles_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function IO_TruncateOutputFiles has not been provided by any thorn in your thornlist");
  }

  retval = (*IO_TruncateOutputFiles_C_Wrapper)(GH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(IO_TruncateOutputFiles) (const CCTK_POINTER_TO_CONST* GH);
CCTK_INT CCTK_FCALL CCTK_FNAME(IO_TruncateOutputFiles) (const CCTK_POINTER_TO_CONST* GH)
{
  CCTK_INT retval;

  if (!IO_TruncateOutputFiles_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function IO_TruncateOutputFiles has not been provided by any thorn in your thornlist");
  }

  retval = (*IO_TruncateOutputFiles_F_Wrapper)(GH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedIO_TruncateOutputFiles(void);
CCTK_INT IsAliasedIO_TruncateOutputFiles(void)
{
  return (IO_TruncateOutputFiles_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasIO_TruncateOutputFiles_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH));
CCTK_INT AliasIO_TruncateOutputFiles_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH))
{
  CCTK_INT aliased = IO_TruncateOutputFiles_C_Wrapper != NULL;
  if (!aliased)
  {
    IO_TruncateOutputFiles_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasIO_TruncateOutputFiles_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH));
CCTK_INT AliasIO_TruncateOutputFiles_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH))
{
  CCTK_INT aliased = IO_TruncateOutputFiles_C_Wrapper != NULL;
  if (!aliased)
  {
    IO_TruncateOutputFiles_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToConstrained_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLChangeToConstrained_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToConstrained (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLChangeToConstrained (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToConstrained_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToConstrained has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLChangeToConstrained_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToConstrained) (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToConstrained) (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToConstrained_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToConstrained has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLChangeToConstrained_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToConstrained(void);
CCTK_INT IsAliasedMoLChangeToConstrained(void)
{
  return (MoLChangeToConstrained_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLChangeToConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLChangeToConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToConstrained_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLChangeToConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLChangeToConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToConstrained_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToEvolved_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLChangeToEvolved_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLChangeToEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolved_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolved has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLChangeToEvolved_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToEvolved) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToEvolved) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolved_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolved has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLChangeToEvolved_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToEvolved(void);
CCTK_INT IsAliasedMoLChangeToEvolved(void)
{
  return (MoLChangeToEvolved_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLChangeToEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLChangeToEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolved_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLChangeToEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLChangeToEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolved_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToNone_C_Wrapper) (const CCTK_INT RemoveIndex) = NULL;
static CCTK_INT (*MoLChangeToNone_F_Wrapper) (const CCTK_INT* RemoveIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToNone (const CCTK_INT RemoveIndex);
CCTK_INT MoLChangeToNone (const CCTK_INT RemoveIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToNone_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToNone has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLChangeToNone_C_Wrapper)(RemoveIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToNone) (const CCTK_INT* RemoveIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToNone) (const CCTK_INT* RemoveIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToNone_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToNone has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLChangeToNone_F_Wrapper)(RemoveIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToNone(void);
CCTK_INT IsAliasedMoLChangeToNone(void)
{
  return (MoLChangeToNone_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToNone_C(CCTK_INT (*func)(const CCTK_INT RemoveIndex));
CCTK_INT AliasMoLChangeToNone_C(CCTK_INT (*func)(const CCTK_INT RemoveIndex))
{
  CCTK_INT aliased = MoLChangeToNone_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToNone_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToNone_F(CCTK_INT (*func)(const CCTK_INT* RemoveIndex));
CCTK_INT AliasMoLChangeToNone_F(CCTK_INT (*func)(const CCTK_INT* RemoveIndex))
{
  CCTK_INT aliased = MoLChangeToNone_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToNone_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToSaveAndRestore_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLChangeToSaveAndRestore_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToSaveAndRestore (const CCTK_INT SandRIndex);
CCTK_INT MoLChangeToSaveAndRestore (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToSaveAndRestore_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToSaveAndRestore has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLChangeToSaveAndRestore_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToSaveAndRestore) (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLChangeToSaveAndRestore) (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToSaveAndRestore_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToSaveAndRestore has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLChangeToSaveAndRestore_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToSaveAndRestore(void);
CCTK_INT IsAliasedMoLChangeToSaveAndRestore(void)
{
  return (MoLChangeToSaveAndRestore_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLChangeToSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLChangeToSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToSaveAndRestore_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLChangeToSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLChangeToSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToSaveAndRestore_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLNumIntegratorSubsteps_C_Wrapper) (void) = NULL;
static CCTK_INT (*MoLNumIntegratorSubsteps_F_Wrapper) (void) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLNumIntegratorSubsteps (void);
CCTK_INT MoLNumIntegratorSubsteps (void)
{
  CCTK_INT retval;

  if (!MoLNumIntegratorSubsteps_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLNumIntegratorSubsteps has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLNumIntegratorSubsteps_C_Wrapper)();
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLNumIntegratorSubsteps) (void);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLNumIntegratorSubsteps) (void)
{
  CCTK_INT retval;

  if (!MoLNumIntegratorSubsteps_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLNumIntegratorSubsteps has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLNumIntegratorSubsteps_F_Wrapper)();
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLNumIntegratorSubsteps(void);
CCTK_INT IsAliasedMoLNumIntegratorSubsteps(void)
{
  return (MoLNumIntegratorSubsteps_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLNumIntegratorSubsteps_C(CCTK_INT (*func)(void));
CCTK_INT AliasMoLNumIntegratorSubsteps_C(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = MoLNumIntegratorSubsteps_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLNumIntegratorSubsteps_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLNumIntegratorSubsteps_F(CCTK_INT (*func)(void));
CCTK_INT AliasMoLNumIntegratorSubsteps_F(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = MoLNumIntegratorSubsteps_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLNumIntegratorSubsteps_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLQueryEvolvedRHS_C_Wrapper) (const CCTK_INT EvolvedIndex) = NULL;
static CCTK_INT (*MoLQueryEvolvedRHS_F_Wrapper) (const CCTK_INT* EvolvedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLQueryEvolvedRHS (const CCTK_INT EvolvedIndex);
CCTK_INT MoLQueryEvolvedRHS (const CCTK_INT EvolvedIndex)
{
  CCTK_INT retval;

  if (!MoLQueryEvolvedRHS_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLQueryEvolvedRHS has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLQueryEvolvedRHS_C_Wrapper)(EvolvedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLQueryEvolvedRHS) (const CCTK_INT* EvolvedIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLQueryEvolvedRHS) (const CCTK_INT* EvolvedIndex)
{
  CCTK_INT retval;

  if (!MoLQueryEvolvedRHS_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLQueryEvolvedRHS has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLQueryEvolvedRHS_F_Wrapper)(EvolvedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLQueryEvolvedRHS(void);
CCTK_INT IsAliasedMoLQueryEvolvedRHS(void)
{
  return (MoLQueryEvolvedRHS_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLQueryEvolvedRHS_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex));
CCTK_INT AliasMoLQueryEvolvedRHS_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex))
{
  CCTK_INT aliased = MoLQueryEvolvedRHS_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLQueryEvolvedRHS_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLQueryEvolvedRHS_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex));
CCTK_INT AliasMoLQueryEvolvedRHS_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex))
{
  CCTK_INT aliased = MoLQueryEvolvedRHS_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLQueryEvolvedRHS_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterConstrained_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLRegisterConstrained_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterConstrained (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLRegisterConstrained (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrained_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrained has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterConstrained_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterConstrained) (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterConstrained) (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrained_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrained has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterConstrained_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterConstrained(void);
CCTK_INT IsAliasedMoLRegisterConstrained(void)
{
  return (MoLRegisterConstrained_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrained_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrained_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterConstrainedGroup_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLRegisterConstrainedGroup_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterConstrainedGroup (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLRegisterConstrainedGroup (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrainedGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrainedGroup has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterConstrainedGroup_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterConstrainedGroup) (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterConstrainedGroup) (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrainedGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrainedGroup has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterConstrainedGroup_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterConstrainedGroup(void);
CCTK_INT IsAliasedMoLRegisterConstrainedGroup(void)
{
  return (MoLRegisterConstrainedGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterConstrainedGroup_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrainedGroup_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrainedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrainedGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterConstrainedGroup_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrainedGroup_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrainedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrainedGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolved_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLRegisterEvolved_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLRegisterEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolved_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolved has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterEvolved_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolved) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolved) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolved_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolved has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterEvolved_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolved(void);
CCTK_INT IsAliasedMoLRegisterEvolved(void)
{
  return (MoLRegisterEvolved_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLRegisterEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolved_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLRegisterEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolved_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolvedGroup_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLRegisterEvolvedGroup_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolvedGroup (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLRegisterEvolvedGroup (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroup has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterEvolvedGroup_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolvedGroup) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterEvolvedGroup) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroup has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterEvolvedGroup_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolvedGroup(void);
CCTK_INT IsAliasedMoLRegisterEvolvedGroup(void)
{
  return (MoLRegisterEvolvedGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolvedGroup_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLRegisterEvolvedGroup_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolvedGroup_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLRegisterEvolvedGroup_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterSaveAndRestore_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLRegisterSaveAndRestore_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterSaveAndRestore (const CCTK_INT SandRIndex);
CCTK_INT MoLRegisterSaveAndRestore (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestore_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestore has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterSaveAndRestore_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterSaveAndRestore) (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterSaveAndRestore) (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestore_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestore has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterSaveAndRestore_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterSaveAndRestore(void);
CCTK_INT IsAliasedMoLRegisterSaveAndRestore(void)
{
  return (MoLRegisterSaveAndRestore_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestore_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestore_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterSaveAndRestoreGroup_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLRegisterSaveAndRestoreGroup_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterSaveAndRestoreGroup (const CCTK_INT SandRIndex);
CCTK_INT MoLRegisterSaveAndRestoreGroup (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestoreGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestoreGroup has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterSaveAndRestoreGroup_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterSaveAndRestoreGroup) (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL CCTK_FNAME(MoLRegisterSaveAndRestoreGroup) (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestoreGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestoreGroup has not been provided by any thorn in your thornlist");
  }

  retval = (*MoLRegisterSaveAndRestoreGroup_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterSaveAndRestoreGroup(void);
CCTK_INT IsAliasedMoLRegisterSaveAndRestoreGroup(void)
{
  return (MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestoreGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestoreGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_ConvertFromPhysicalBoundary (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT MultiPatch_ConvertFromPhysicalBoundary (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_ConvertFromPhysicalBoundary has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_ConvertFromPhysicalBoundary) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_ConvertFromPhysicalBoundary) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_ConvertFromPhysicalBoundary has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_ConvertFromPhysicalBoundary(void);
CCTK_INT IsAliasedMultiPatch_ConvertFromPhysicalBoundary(void)
{
  return (MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetBoundarySpecification_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;
static CCTK_INT (*MultiPatch_GetBoundarySpecification_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetBoundarySpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT MultiPatch_GetBoundarySpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBoundarySpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBoundarySpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_GetBoundarySpecification_C_Wrapper)(map , size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetBoundarySpecification) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetBoundarySpecification) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBoundarySpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBoundarySpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_GetBoundarySpecification_F_Wrapper)(map , size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetBoundarySpecification(void);
CCTK_INT IsAliasedMultiPatch_GetBoundarySpecification(void)
{
  return (MultiPatch_GetBoundarySpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasMultiPatch_GetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = MultiPatch_GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBoundarySpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasMultiPatch_GetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = MultiPatch_GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBoundarySpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetDomainSpecification_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;
static CCTK_INT (*MultiPatch_GetDomainSpecification_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetDomainSpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT MultiPatch_GetDomainSpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_GetDomainSpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetDomainSpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_GetDomainSpecification_C_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetDomainSpecification) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetDomainSpecification) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_GetDomainSpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetDomainSpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_GetDomainSpecification_F_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetDomainSpecification(void);
CCTK_INT IsAliasedMultiPatch_GetDomainSpecification(void)
{
  return (MultiPatch_GetDomainSpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_GetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetDomainSpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_GetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetDomainSpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetMap_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*MultiPatch_GetMap_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetMap (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT MultiPatch_GetMap (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!MultiPatch_GetMap_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetMap has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_GetMap_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetMap) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetMap) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!MultiPatch_GetMap_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetMap has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_GetMap_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetMap(void);
CCTK_INT IsAliasedMultiPatch_GetMap(void)
{
  return (MultiPatch_GetMap_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetMap_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasMultiPatch_GetMap_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = MultiPatch_GetMap_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetMap_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetMap_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasMultiPatch_GetMap_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = MultiPatch_GetMap_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetMap_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetSystemSpecification_C_Wrapper) (CCTK_INT* maps) = NULL;
static CCTK_INT (*MultiPatch_GetSystemSpecification_F_Wrapper) (CCTK_INT* maps) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetSystemSpecification (CCTK_INT* maps);
CCTK_INT MultiPatch_GetSystemSpecification (CCTK_INT* maps)
{
  CCTK_INT retval;

  if (!MultiPatch_GetSystemSpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetSystemSpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_GetSystemSpecification_C_Wrapper)(maps);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetSystemSpecification) (CCTK_INT* maps);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_GetSystemSpecification) (CCTK_INT* maps)
{
  CCTK_INT retval;

  if (!MultiPatch_GetSystemSpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetSystemSpecification has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_GetSystemSpecification_F_Wrapper)(maps);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetSystemSpecification(void);
CCTK_INT IsAliasedMultiPatch_GetSystemSpecification(void)
{
  return (MultiPatch_GetSystemSpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetSystemSpecification_C(CCTK_INT (*func)(CCTK_INT* maps));
CCTK_INT AliasMultiPatch_GetSystemSpecification_C(CCTK_INT (*func)(CCTK_INT* maps))
{
  CCTK_INT aliased = MultiPatch_GetSystemSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetSystemSpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetSystemSpecification_F(CCTK_INT (*func)(CCTK_INT* maps));
CCTK_INT AliasMultiPatch_GetSystemSpecification_F(CCTK_INT (*func)(CCTK_INT* maps))
{
  CCTK_INT aliased = MultiPatch_GetSystemSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetSystemSpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_MapIsCartesian_C_Wrapper) (const CCTK_INT map) = NULL;
static CCTK_INT (*MultiPatch_MapIsCartesian_F_Wrapper) (const CCTK_INT* map) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_MapIsCartesian (const CCTK_INT map);
CCTK_INT MultiPatch_MapIsCartesian (const CCTK_INT map)
{
  CCTK_INT retval;

  if (!MultiPatch_MapIsCartesian_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_MapIsCartesian has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_MapIsCartesian_C_Wrapper)(map);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_MapIsCartesian) (const CCTK_INT* map);
CCTK_INT CCTK_FCALL CCTK_FNAME(MultiPatch_MapIsCartesian) (const CCTK_INT* map)
{
  CCTK_INT retval;

  if (!MultiPatch_MapIsCartesian_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_MapIsCartesian has not been provided by any thorn in your thornlist");
  }

  retval = (*MultiPatch_MapIsCartesian_F_Wrapper)(map);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_MapIsCartesian(void);
CCTK_INT IsAliasedMultiPatch_MapIsCartesian(void)
{
  return (MultiPatch_MapIsCartesian_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_MapIsCartesian_C(CCTK_INT (*func)(const CCTK_INT map));
CCTK_INT AliasMultiPatch_MapIsCartesian_C(CCTK_INT (*func)(const CCTK_INT map))
{
  CCTK_INT aliased = MultiPatch_MapIsCartesian_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_MapIsCartesian_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_MapIsCartesian_F(CCTK_INT (*func)(const CCTK_INT* map));
CCTK_INT AliasMultiPatch_MapIsCartesian_F(CCTK_INT (*func)(const CCTK_INT* map))
{
  CCTK_INT aliased = MultiPatch_MapIsCartesian_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_MapIsCartesian_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*PhysToConfInPlace_C_Wrapper) (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;
static void (*PhysToConfInPlace_F_Wrapper) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void PhysToConfInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void PhysToConfInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!PhysToConfInPlace_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PhysToConfInPlace has not been provided by any thorn in your thornlist");
  }

  (*PhysToConfInPlace_C_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

void CCTK_FCALL CCTK_FNAME(PhysToConfInPlace) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void CCTK_FCALL CCTK_FNAME(PhysToConfInPlace) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!PhysToConfInPlace_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PhysToConfInPlace has not been provided by any thorn in your thornlist");
  }

  (*PhysToConfInPlace_F_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPhysToConfInPlace(void);
CCTK_INT IsAliasedPhysToConfInPlace(void)
{
  return (PhysToConfInPlace_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPhysToConfInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasPhysToConfInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = PhysToConfInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    PhysToConfInPlace_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPhysToConfInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasPhysToConfInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = PhysToConfInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    PhysToConfInPlace_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*QueryProlongating_C_Wrapper) (void) = NULL;
static CCTK_INT (*QueryProlongating_F_Wrapper) (void) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT QueryProlongating (void);
CCTK_INT QueryProlongating (void)
{
  CCTK_INT retval;

  if (!QueryProlongating_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function QueryProlongating has not been provided by any thorn in your thornlist");
  }

  retval = (*QueryProlongating_C_Wrapper)();
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(QueryProlongating) (void);
CCTK_INT CCTK_FCALL CCTK_FNAME(QueryProlongating) (void)
{
  CCTK_INT retval;

  if (!QueryProlongating_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function QueryProlongating has not been provided by any thorn in your thornlist");
  }

  retval = (*QueryProlongating_F_Wrapper)();
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedQueryProlongating(void);
CCTK_INT IsAliasedQueryProlongating(void)
{
  return (QueryProlongating_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasQueryProlongating_C(CCTK_INT (*func)(void));
CCTK_INT AliasQueryProlongating_C(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = QueryProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    QueryProlongating_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasQueryProlongating_F(CCTK_INT (*func)(void));
CCTK_INT AliasQueryProlongating_F(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = QueryProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    QueryProlongating_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*RegisterScheduleWrapper_C_Wrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)) = NULL;
static CCTK_INT (*RegisterScheduleWrapper_F_Wrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT RegisterScheduleWrapper (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data));
CCTK_INT RegisterScheduleWrapper (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data))
{
  CCTK_INT retval;

  if (!RegisterScheduleWrapper_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function RegisterScheduleWrapper has not been provided by any thorn in your thornlist");
  }

  retval = (*RegisterScheduleWrapper_C_Wrapper)(func_before , func_after);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(RegisterScheduleWrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data));
CCTK_INT CCTK_FCALL CCTK_FNAME(RegisterScheduleWrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data))
{
  CCTK_INT retval;

  if (!RegisterScheduleWrapper_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function RegisterScheduleWrapper has not been provided by any thorn in your thornlist");
  }

  retval = (*RegisterScheduleWrapper_F_Wrapper)(func_before , func_after);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedRegisterScheduleWrapper(void);
CCTK_INT IsAliasedRegisterScheduleWrapper(void)
{
  return (RegisterScheduleWrapper_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasRegisterScheduleWrapper_C(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)));
CCTK_INT AliasRegisterScheduleWrapper_C(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)))
{
  CCTK_INT aliased = RegisterScheduleWrapper_C_Wrapper != NULL;
  if (!aliased)
  {
    RegisterScheduleWrapper_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasRegisterScheduleWrapper_F(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)));
CCTK_INT AliasRegisterScheduleWrapper_F(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)))
{
  CCTK_INT aliased = RegisterScheduleWrapper_C_Wrapper != NULL;
  if (!aliased)
  {
    RegisterScheduleWrapper_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*RegridLevel_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels) = NULL;
static CCTK_INT (*RegridLevel_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT RegridLevel (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels);
CCTK_INT RegridLevel (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels)
{
  CCTK_INT retval;

  if (!RegridLevel_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function RegridLevel has not been provided by any thorn in your thornlist");
  }

  retval = (*RegridLevel_C_Wrapper)(cctkGH , current_max_reflevel , max_reflevels);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(RegridLevel) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels);
CCTK_INT CCTK_FCALL CCTK_FNAME(RegridLevel) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels)
{
  CCTK_INT retval;

  if (!RegridLevel_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function RegridLevel has not been provided by any thorn in your thornlist");
  }

  retval = (*RegridLevel_F_Wrapper)(cctkGH , current_max_reflevel , max_reflevels);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedRegridLevel(void);
CCTK_INT IsAliasedRegridLevel(void)
{
  return (RegridLevel_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasRegridLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels));
CCTK_INT AliasRegridLevel_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT current_max_reflevel ,
 const CCTK_INT max_reflevels))
{
  CCTK_INT aliased = RegridLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    RegridLevel_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasRegridLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels));
CCTK_INT AliasRegridLevel_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* current_max_reflevel ,
 const CCTK_INT* max_reflevels))
{
  CCTK_INT aliased = RegridLevel_C_Wrapper != NULL;
  if (!aliased)
  {
    RegridLevel_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*SetDriftCorrectPosition_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z) = NULL;
static void (*SetDriftCorrectPosition_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void SetDriftCorrectPosition (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z);
void SetDriftCorrectPosition (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z)
{
  if (!SetDriftCorrectPosition_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SetDriftCorrectPosition has not been provided by any thorn in your thornlist");
  }

  (*SetDriftCorrectPosition_C_Wrapper)(GH , x , y , z);
}

void CCTK_FCALL CCTK_FNAME(SetDriftCorrectPosition) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z);
void CCTK_FCALL CCTK_FNAME(SetDriftCorrectPosition) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z)
{
  if (!SetDriftCorrectPosition_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SetDriftCorrectPosition has not been provided by any thorn in your thornlist");
  }

  (*SetDriftCorrectPosition_F_Wrapper)(GH , x , y , z);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSetDriftCorrectPosition(void);
CCTK_INT IsAliasedSetDriftCorrectPosition(void)
{
  return (SetDriftCorrectPosition_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSetDriftCorrectPosition_C(void (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z));
CCTK_INT AliasSetDriftCorrectPosition_C(void (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_REAL x ,
 const CCTK_REAL y ,
 const CCTK_REAL z))
{
  CCTK_INT aliased = SetDriftCorrectPosition_C_Wrapper != NULL;
  if (!aliased)
  {
    SetDriftCorrectPosition_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSetDriftCorrectPosition_F(void (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z));
CCTK_INT AliasSetDriftCorrectPosition_F(void (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_REAL* x ,
 const CCTK_REAL* y ,
 const CCTK_REAL* z))
{
  CCTK_INT aliased = SetDriftCorrectPosition_C_Wrapper != NULL;
  if (!aliased)
  {
    SetDriftCorrectPosition_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryHandleOfName_C_Wrapper) (CCTK_STRING sym_name) = NULL;
static CCTK_INT (*SymmetryHandleOfName_F_Wrapper) (CCTK_STRING sym_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryHandleOfName (CCTK_STRING sym_name);
CCTK_INT SymmetryHandleOfName (CCTK_STRING sym_name)
{
  CCTK_INT retval;

  if (!SymmetryHandleOfName_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryHandleOfName has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryHandleOfName_C_Wrapper)(sym_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryHandleOfName) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryHandleOfName) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryHandleOfName_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryHandleOfName has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryHandleOfName_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryHandleOfName(void);
CCTK_INT IsAliasedSymmetryHandleOfName(void)
{
  return (SymmetryHandleOfName_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryHandleOfName_C(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryHandleOfName_C(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryHandleOfName_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryHandleOfName_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryHandleOfName_F(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryHandleOfName_F(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryHandleOfName_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryHandleOfName_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryInterpolate_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;
static CCTK_INT (*SymmetryInterpolate_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT SymmetryInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!SymmetryInterpolate_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolate has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryInterpolate_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryInterpolate) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryInterpolate) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!SymmetryInterpolate_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolate has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryInterpolate_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryInterpolate(void);
CCTK_INT IsAliasedSymmetryInterpolate(void)
{
  return (SymmetryInterpolate_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasSymmetryInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = SymmetryInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolate_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasSymmetryInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = SymmetryInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolate_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryInterpolateFaces_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces) = NULL;
static CCTK_INT (*SymmetryInterpolateFaces_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryInterpolateFaces (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces);
CCTK_INT SymmetryInterpolateFaces (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)
{
  CCTK_INT retval;

  if (!SymmetryInterpolateFaces_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolateFaces has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryInterpolateFaces_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays , faces);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryInterpolateFaces) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryInterpolateFaces) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)
{
  CCTK_INT retval;

  if (!SymmetryInterpolateFaces_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolateFaces has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryInterpolateFaces_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays , faces);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryInterpolateFaces(void);
CCTK_INT IsAliasedSymmetryInterpolateFaces(void)
{
  return (SymmetryInterpolateFaces_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryInterpolateFaces_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces));
CCTK_INT AliasSymmetryInterpolateFaces_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces))
{
  CCTK_INT aliased = SymmetryInterpolateFaces_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolateFaces_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryInterpolateFaces_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces));
CCTK_INT AliasSymmetryInterpolateFaces_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces))
{
  CCTK_INT aliased = SymmetryInterpolateFaces_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolateFaces_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*SymmetryNameOfHandle_C_Wrapper) (const CCTK_INT sym_handle) = NULL;
static CCTK_POINTER_TO_CONST (*SymmetryNameOfHandle_F_Wrapper) (const CCTK_INT* sym_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST SymmetryNameOfHandle (const CCTK_INT sym_handle);
CCTK_POINTER_TO_CONST SymmetryNameOfHandle (const CCTK_INT sym_handle)
{
  CCTK_POINTER_TO_CONST retval;

  if (!SymmetryNameOfHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryNameOfHandle has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryNameOfHandle_C_Wrapper)(sym_handle);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(SymmetryNameOfHandle) (const CCTK_INT* sym_handle);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(SymmetryNameOfHandle) (const CCTK_INT* sym_handle)
{
  CCTK_POINTER_TO_CONST retval;

  if (!SymmetryNameOfHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryNameOfHandle has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryNameOfHandle_F_Wrapper)(sym_handle);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryNameOfHandle(void);
CCTK_INT IsAliasedSymmetryNameOfHandle(void)
{
  return (SymmetryNameOfHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryNameOfHandle_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT sym_handle));
CCTK_INT AliasSymmetryNameOfHandle_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT sym_handle))
{
  CCTK_INT aliased = SymmetryNameOfHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryNameOfHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryNameOfHandle_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT* sym_handle));
CCTK_INT AliasSymmetryNameOfHandle_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT* sym_handle))
{
  CCTK_INT aliased = SymmetryNameOfHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryNameOfHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegister_C_Wrapper) (CCTK_STRING sym_name) = NULL;
static CCTK_INT (*SymmetryRegister_F_Wrapper) (CCTK_STRING sym_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegister (CCTK_STRING sym_name);
CCTK_INT SymmetryRegister (CCTK_STRING sym_name)
{
  CCTK_INT retval;

  if (!SymmetryRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegister has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegister_C_Wrapper)(sym_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegister) (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegister) (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegister has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegister_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegister(void);
CCTK_INT IsAliasedSymmetryRegister(void)
{
  return (SymmetryRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegister_C(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryRegister_C(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegister_F(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryRegister_F(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGI_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index) = NULL;
static CCTK_INT (*SymmetryRegisterGI_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGI (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index);
CCTK_INT SymmetryRegisterGI (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGI has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegisterGI_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_index);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGI) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGI) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGI has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegisterGI_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_index);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGI(void);
CCTK_INT IsAliasedSymmetryRegisterGI(void)
{
  return (SymmetryRegisterGI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGI_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index));
CCTK_INT AliasSymmetryRegisterGI_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index))
{
  CCTK_INT aliased = SymmetryRegisterGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGI_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index));
CCTK_INT AliasSymmetryRegisterGI_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index))
{
  CCTK_INT aliased = SymmetryRegisterGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGN_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name) = NULL;
static CCTK_INT (*SymmetryRegisterGN_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGN (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name);
CCTK_INT SymmetryRegisterGN (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGN has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegisterGN_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGN) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGN) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryRegisterGN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGN has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegisterGN_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGN(void);
CCTK_INT IsAliasedSymmetryRegisterGN(void)
{
  return (SymmetryRegisterGN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGN_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryRegisterGN_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryRegisterGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGN_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryRegisterGN_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryRegisterGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGrid_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width) = NULL;
static CCTK_INT (*SymmetryRegisterGrid_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGrid (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width);
CCTK_INT SymmetryRegisterGrid (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGrid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGrid has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegisterGrid_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGrid) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGrid) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGrid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGrid has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegisterGrid_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGrid(void);
CCTK_INT IsAliasedSymmetryRegisterGrid(void)
{
  return (SymmetryRegisterGrid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGrid_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width));
CCTK_INT AliasSymmetryRegisterGrid_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width))
{
  CCTK_INT aliased = SymmetryRegisterGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGrid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGrid_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width));
CCTK_INT AliasSymmetryRegisterGrid_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width))
{
  CCTK_INT aliased = SymmetryRegisterGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGrid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGridInterpolator_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)) = NULL;
static CCTK_INT (*SymmetryRegisterGridInterpolator_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGridInterpolator (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces));
CCTK_INT SymmetryRegisterGridInterpolator (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces))
{
  CCTK_INT retval;

  if (!SymmetryRegisterGridInterpolator_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGridInterpolator has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegisterGridInterpolator_C_Wrapper)(cctkGH , sym_handle , symmetry_interpolate);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGridInterpolator) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces));
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryRegisterGridInterpolator) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces))
{
  CCTK_INT retval;

  if (!SymmetryRegisterGridInterpolator_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGridInterpolator has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryRegisterGridInterpolator_F_Wrapper)(cctkGH , sym_handle , symmetry_interpolate);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGridInterpolator(void);
CCTK_INT IsAliasedSymmetryRegisterGridInterpolator(void)
{
  return (SymmetryRegisterGridInterpolator_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGridInterpolator_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)));
CCTK_INT AliasSymmetryRegisterGridInterpolator_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)))
{
  CCTK_INT aliased = SymmetryRegisterGridInterpolator_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGridInterpolator_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGridInterpolator_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)));
CCTK_INT AliasSymmetryRegisterGridInterpolator_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)))
{
  CCTK_INT aliased = SymmetryRegisterGridInterpolator_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGridInterpolator_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGI_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index) = NULL;
static CCTK_INT (*SymmetryTableHandleForGI_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index);
CCTK_INT SymmetryTableHandleForGI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGI has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryTableHandleForGI_C_Wrapper)(cctkGH , group_index);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGI has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryTableHandleForGI_F_Wrapper)(cctkGH , group_index);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGI(void);
CCTK_INT IsAliasedSymmetryTableHandleForGI(void)
{
  return (SymmetryTableHandleForGI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index));
CCTK_INT AliasSymmetryTableHandleForGI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index))
{
  CCTK_INT aliased = SymmetryTableHandleForGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index));
CCTK_INT AliasSymmetryTableHandleForGI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index))
{
  CCTK_INT aliased = SymmetryTableHandleForGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name) = NULL;
static CCTK_INT (*SymmetryTableHandleForGN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGN (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name);
CCTK_INT SymmetryTableHandleForGN (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGN has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryTableHandleForGN_C_Wrapper)(cctkGH , group_name);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGN) (const CCTK_POINTER_TO_CONST* cctkGH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

  ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryTableHandleForGN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGN has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryTableHandleForGN_F_Wrapper)(cctkGH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGN(void);
CCTK_INT IsAliasedSymmetryTableHandleForGN(void)
{
  return (SymmetryTableHandleForGN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryTableHandleForGN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryTableHandleForGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryTableHandleForGN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryTableHandleForGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGrid_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*SymmetryTableHandleForGrid_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGrid (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT SymmetryTableHandleForGrid (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGrid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGrid has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryTableHandleForGrid_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGrid) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL CCTK_FNAME(SymmetryTableHandleForGrid) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGrid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGrid has not been provided by any thorn in your thornlist");
  }

  retval = (*SymmetryTableHandleForGrid_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGrid(void);
CCTK_INT IsAliasedSymmetryTableHandleForGrid(void)
{
  return (SymmetryTableHandleForGrid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasSymmetryTableHandleForGrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = SymmetryTableHandleForGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGrid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasSymmetryTableHandleForGrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = SymmetryTableHandleForGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGrid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*UnRegisterScheduleWrapper_C_Wrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)) = NULL;
static CCTK_INT (*UnRegisterScheduleWrapper_F_Wrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT UnRegisterScheduleWrapper (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data));
CCTK_INT UnRegisterScheduleWrapper (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data))
{
  CCTK_INT retval;

  if (!UnRegisterScheduleWrapper_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UnRegisterScheduleWrapper has not been provided by any thorn in your thornlist");
  }

  retval = (*UnRegisterScheduleWrapper_C_Wrapper)(func_before , func_after);
  return (retval);
}

CCTK_INT CCTK_FCALL CCTK_FNAME(UnRegisterScheduleWrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data));
CCTK_INT CCTK_FCALL CCTK_FNAME(UnRegisterScheduleWrapper) (CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data))
{
  CCTK_INT retval;

  if (!UnRegisterScheduleWrapper_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UnRegisterScheduleWrapper has not been provided by any thorn in your thornlist");
  }

  retval = (*UnRegisterScheduleWrapper_F_Wrapper)(func_before , func_after);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUnRegisterScheduleWrapper(void);
CCTK_INT IsAliasedUnRegisterScheduleWrapper(void)
{
  return (UnRegisterScheduleWrapper_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUnRegisterScheduleWrapper_C(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)));
CCTK_INT AliasUnRegisterScheduleWrapper_C(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_POINTER function ,
 const CCTK_POINTER attribute ,
 const CCTK_POINTER data)))
{
  CCTK_INT aliased = UnRegisterScheduleWrapper_C_Wrapper != NULL;
  if (!aliased)
  {
    UnRegisterScheduleWrapper_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUnRegisterScheduleWrapper_F(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)));
CCTK_INT AliasUnRegisterScheduleWrapper_F(CCTK_INT (*func)(CCTK_INT (*const func_before)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data) ,
 CCTK_INT (*const func_after)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_POINTER* function ,
 const CCTK_POINTER* attribute ,
 const CCTK_POINTER* data)))
{
  CCTK_INT aliased = UnRegisterScheduleWrapper_C_Wrapper != NULL;
  if (!aliased)
  {
    UnRegisterScheduleWrapper_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueBuildID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueBuildID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueBuildID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueBuildID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueBuildID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueBuildID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueBuildID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueBuildID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueBuildID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueBuildID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueBuildID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueBuildID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueBuildID(void);
CCTK_INT IsAliasedUniqueBuildID(void)
{
  return (UniqueBuildID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueBuildID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueBuildID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueBuildID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueBuildID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueBuildID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueBuildID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueBuildID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueBuildID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueConfigID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueConfigID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueConfigID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueConfigID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueConfigID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueConfigID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueConfigID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueConfigID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueConfigID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueConfigID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueConfigID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueConfigID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueConfigID(void);
CCTK_INT IsAliasedUniqueConfigID(void)
{
  return (UniqueConfigID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueConfigID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueConfigID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueConfigID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueConfigID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueConfigID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueConfigID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueConfigID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueConfigID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueRunID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueRunID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueRunID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueRunID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueRunID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueRunID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueRunID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueRunID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueRunID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueRunID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueRunID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueRunID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueRunID(void);
CCTK_INT IsAliasedUniqueRunID(void)
{
  return (UniqueRunID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueRunID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueRunID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueRunID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueRunID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueRunID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueRunID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueRunID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueRunID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueSimulationID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueSimulationID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueSimulationID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueSimulationID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueSimulationID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueSimulationID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueSimulationID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueSimulationID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueSimulationID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueSimulationID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueSimulationID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueSimulationID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueSimulationID(void);
CCTK_INT IsAliasedUniqueSimulationID(void)
{
  return (UniqueSimulationID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueSimulationID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueSimulationID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueSimulationID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueSimulationID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueSimulationID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueSimulationID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueSimulationID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueSimulationID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*UniqueSourceID_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_POINTER_TO_CONST (*UniqueSourceID_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST UniqueSourceID (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_POINTER_TO_CONST UniqueSourceID (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueSourceID_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueSourceID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueSourceID_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueSourceID) (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_POINTER_TO_CONST CCTK_FCALL CCTK_FNAME(UniqueSourceID) (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_POINTER_TO_CONST retval;

  if (!UniqueSourceID_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function UniqueSourceID has not been provided by any thorn in your thornlist");
  }

  retval = (*UniqueSourceID_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedUniqueSourceID(void);
CCTK_INT IsAliasedUniqueSourceID(void)
{
  return (UniqueSourceID_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasUniqueSourceID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasUniqueSourceID_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = UniqueSourceID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueSourceID_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasUniqueSourceID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasUniqueSourceID_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = UniqueSourceID_C_Wrapper != NULL;
  if (!aliased)
  {
    UniqueSourceID_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER (*VarDataPtrI_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex) = NULL;
static CCTK_POINTER (*VarDataPtrI_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER VarDataPtrI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex);
CCTK_POINTER VarDataPtrI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex)
{
  CCTK_POINTER retval;

  if (!VarDataPtrI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function VarDataPtrI has not been provided by any thorn in your thornlist");
  }

  retval = (*VarDataPtrI_C_Wrapper)(cctkGH , map , reflevel , component , timelevel , varindex);
  return (retval);
}

CCTK_POINTER CCTK_FCALL CCTK_FNAME(VarDataPtrI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex);
CCTK_POINTER CCTK_FCALL CCTK_FNAME(VarDataPtrI) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex)
{
  CCTK_POINTER retval;

  if (!VarDataPtrI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function VarDataPtrI has not been provided by any thorn in your thornlist");
  }

  retval = (*VarDataPtrI_F_Wrapper)(cctkGH , map , reflevel , component , timelevel , varindex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedVarDataPtrI(void);
CCTK_INT IsAliasedVarDataPtrI(void)
{
  return (VarDataPtrI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasVarDataPtrI_C(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex));
CCTK_INT AliasVarDataPtrI_C(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT map ,
 const CCTK_INT reflevel ,
 const CCTK_INT component ,
 const CCTK_INT timelevel ,
 const CCTK_INT varindex))
{
  CCTK_INT aliased = VarDataPtrI_C_Wrapper != NULL;
  if (!aliased)
  {
    VarDataPtrI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasVarDataPtrI_F(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex));
CCTK_INT AliasVarDataPtrI_F(CCTK_POINTER (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* map ,
 const CCTK_INT* reflevel ,
 const CCTK_INT* component ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* varindex))
{
  CCTK_INT aliased = VarDataPtrI_C_Wrapper != NULL;
  if (!aliased)
  {
    VarDataPtrI_F_Wrapper = func;
  }
  return aliased;
}
