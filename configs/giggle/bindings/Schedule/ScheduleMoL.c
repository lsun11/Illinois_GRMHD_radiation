/*@@
   @file       ScheduleMoL.c
   @author     Automatically generated by CreateScheduleBindings.pl
   @desc
               Creates the schedule and parameter recovery bindings 
               for thorn MoL
   @enddesc
@@*/

#define THORN_IS_MoL

#include "cctk.h"
#include "cctk_Parameters.h"
#include "cctki_ScheduleBindings.h"

/* prototypes for schedule bindings functions to be registered */
/* Note that this is a cheat, we just need a function pointer. */
extern int MoL_Startup(void);
extern int MoL_ParamCheck(void);
extern int MoL_SetupIndexArrays(void);
extern int MoL_SetupRKCoefficients(void);
extern int MoL_SetScheduleStatus(void);
extern int MoL_ReportNumberVariables(void);
extern int MoL_FillAllLevels(void);
extern int MoL_FillAllLevels(void);
extern int MoL_FillAllLevels(void);
extern int MoL_FillAllLevels(void);
extern int MoL_StartLoop(void);
extern int MoL_StartLoop(void);
extern int MoL_SetCounter(void);
extern int MoL_SetTime(void);
extern int MoL_SetInitialTime(void);
extern int MoL_InitialCopy(void);
extern int MoL_ICNAverage(void);
extern int MoL_InitRHS(void);
extern int MoL_NaNCheck(void);
extern int MoL_GenericRKAdd(void);
extern int MoL_RK2Add(void);
extern int MoL_RK3Add(void);
extern int MoL_RK4Add(void);
extern int MoL_RK45Add(void);
extern int MoL_RK65Add(void);
extern int MoL_RK87Add(void);
extern int MoL_ICNAdd(void);
extern int MoL_ICNAdd(void);
extern int MoL_OldBdry_SetDt(void);
extern int MoL_OldBdry_ResetDt(void);
extern int MoL_DecrementCounter(void);
extern int MoL_ResetTime(void);
extern int MoL_ResetDeltaTime(void);
extern int MoL_RestoreSandR(void);
extern int MoL_InitAdaptiveError(void);
extern int MoL_FindAdaptiveError(void);
extern int MoL_ReduceAdaptiveError(void);
extern int MoL_SetEstimatedDt(void);
extern int MoL_FinishLoop(void);
extern int MoL_FreeIndexArrays(void);


void CCTKi_BindingsSchedule_MoL(void);
void CCTKi_BindingsSchedule_MoL(void)
{
  DECLARE_CCTK_PARAMETERS
  CCTKi_ScheduleGroupStorage("MoL::MoL_Counters",1);
  CCTKi_ScheduleGroupStorage("MoL::MoL_Original_Time",1);
if (MoL_Memory_Always_On)
{
  if (MoL_Num_Evolved_Vars)
  {
    if (MoL_Num_Scratch_Levels) 
    {
  CCTKi_ScheduleGroupStorage("MoL::ScratchSpace",1);
      if (MoL_Max_Evolved_Array_Size)
      {
      }
    }
  }
  else if (MoL_Num_Scratch_Levels) 
  {
    if (MoL_Max_Evolved_Array_Size)
    {
    }
  }
  if (MoL_Num_SaveAndRestore_Vars)
  {
  CCTKi_ScheduleGroupStorage("MoL::SandRScratchSpace",1);
  }  
  if (MoL_Max_Evolved_Array_Size)
  {
  }
}
if (CCTK_Equals(ODE_Method,"Generic"))
{
  CCTKi_ScheduleGroupStorage("MoL::RKAlphaCoefficients",1);
  CCTKi_ScheduleGroupStorage("MoL::RKBetaCoefficients",1);
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_Startup,
                           "MoL_Startup",
                           "MoL",
                           "MethodOfLines",
                           "Startup banner",
                           "CCTK_STARTUP",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_ParamCheck,
                           "MoL_ParamCheck",
                           "MoL",
                           "MethodOfLines",
                           "Basic parameter checking",
                           "CCTK_PARAMCHECK",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_SetupIndexArrays,
                           "MoL_SetupIndexArrays",
                           "MoL",
                           "MethodOfLines",
                           "Set up the MoL bookkeeping index arrays",
                           "CCTK_WRAGH",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
if (CCTK_Equals(ODE_Method,"Generic"))
{
  {
    int cctkschedulei_tlevelarray[] = {1,1,0};
    CCTKi_ScheduleFunction((void *)MoL_SetupRKCoefficients,
                           "MoL_SetupRKCoefficients",
                           "MoL",
                           "MethodOfLines",
                           "Initialize the generic Runge-Kutta coefficients",
                           "CCTK_WRAGH",
                           "C",
                           2,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL::RKAlphaCoefficients",
                           "MoL::RKBetaCoefficients",
                           "GLOBAL");
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_SetScheduleStatus,
                           "MoL_SetScheduleStatus",
                           "MoL",
                           "MethodOfLines",
                           "Set the flag so it is ok to register with MoL",
                           "CCTK_WRAGH",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "GLOBAL",
                           "MoL_SetupIndexArrays");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_Register",
"MoL_Register",
                        "MoL",
                        "MethodOfLines",
                        "The group where physics thorns register variables with MoL",
                        "CCTK_WRAGH",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        1,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL_SetScheduleStatus");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_ReportNumberVariables,
                           "MoL_ReportNumberVariables",
                           "MoL",
                           "MethodOfLines",
                           "Report how many of each type of variable there are",
                           "CCTK_WRAGH",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "META",
                           "MoL_Register");
  }
if (initial_data_is_crap)
{
  if (copy_ID_after_MoL_PostStep)
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_FillAllLevels,
                           "MoL_FillAllLevels",
                           "MoL",
                           "MethodOfLines",
                           "A bad routine. Fills all previous timelevels with data copied from the current.",
                           "CCTK_POSTPOSTINITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           2,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "ABE_PostInitial");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_FillAllLevels,
                           "MoL_FillAllLevels",
                           "MoL",
                           "MethodOfLines",
                           "A bad routine. Fills all previous timelevels with data copied from the current.",
                           "CCTK_POSTINITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep");
  }
  }
  else
  {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_FillAllLevels,
                           "MoL_FillAllLevels",
                           "MoL",
                           "MethodOfLines",
                           "A bad routine. Fills all previous timelevels with data copied from the current.",
                           "CCTK_POSTPOSTINITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           2,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "ABE_PostInitial");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_FillAllLevels,
                           "MoL_FillAllLevels",
                           "MoL",
                           "MethodOfLines",
                           "A bad routine. Fills all previous timelevels with data copied from the current.",
                           "CCTK_POSTINITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep");
  }
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_StartLoop,
                           "MoL_StartLoop",
                           "MoL",
                           "MethodOfLines",
                           "Initialise the step size control",
                           "CCTK_EVOL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_Evolution");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_StartLoop,
                           "MoL_StartLoop",
                           "MoL",
                           "MethodOfLines",
                           "Initialise the step size control",
                           "CCTK_INITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL");
  }
if (MoL_Num_Scratch_Levels)
{
  if (MoL_Num_Evolved_Vars)
  {
    if (MoL_Num_SaveAndRestore_Vars)
    {  
      if (MoL_Max_Evolved_Array_Size)
      {
  {
    int cctkschedulei_tlevelarray[] = {1,1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        2,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::ScratchSpace",
                        "MoL::SandRScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
      else
      {
  {
    int cctkschedulei_tlevelarray[] = {1,1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        2,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::ScratchSpace",
                        "MoL::SandRScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
    }
    else
    {
      if (MoL_Max_Evolved_Array_Size)
      {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::ScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
      else
      {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::ScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
    }
  }
  else 
  {
    if (MoL_Num_SaveAndRestore_Vars)
    {
      if (MoL_Max_Evolved_Array_Size)
      {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::SandRScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
      else
      {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::SandRScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
    }
    else
    {
      if (MoL_Max_Evolved_Array_Size)
      {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::MoL_Stepsize_Bad");
  }
      }
      else
      {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::MoL_Stepsize_Bad");
  }
      }
    }
  }
}
else 
{
  if (MoL_Num_Evolved_Vars)
  {
    if (MoL_Num_SaveAndRestore_Vars)
    {
      if (MoL_Max_Evolved_Array_Size)
      {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::SandRScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
      else
      {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::SandRScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
    }
    else
    {
      if (MoL_Max_Evolved_Array_Size)
      {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::MoL_Stepsize_Bad");
  }
      }
      else
      {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::MoL_Stepsize_Bad");
  }
      }
    }
  }
  else 
  {
    if (MoL_Num_SaveAndRestore_Vars)
    {
      if (MoL_Max_Evolved_Array_Size)
      {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::SandRScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
      else
      {
  {
    int cctkschedulei_tlevelarray[] = {1,0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        1,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::SandRScratchSpace",
                        "MoL::MoL_Stepsize_Bad");
  }
      }
    }
    else
    {
      if (MoL_Max_Evolved_Array_Size)
      {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::MoL_Stepsize_Bad");
  }
      }
      else
      {
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_Evolution",
"MoL_Evolution",
                        "MoL",
                        "MethodOfLines",
                        "A single Cactus evolution step using MoL",
                        "CCTK_EVOL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL::MoL_Stepsize_Bad");
  }
      }
    }
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_StartStep",
"MoL_StartStep",
                        "MoL",
                        "MethodOfLines",
                        "MoL internal setup for the evolution step",
                        "MoL_Evolution",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_SetCounter,
                           "MoL_SetCounter",
                           "MoL",
                           "MethodOfLines",
                           "Set the counter for the ODE method to loop over",
                           "MoL_StartStep",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_SetTime,
                           "MoL_SetTime",
                           "MoL",
                           "MethodOfLines",
                           "Ensure the correct time and timestep are used",
                           "MoL_StartStep",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_SetInitialTime,
                           "MoL_SetInitialTime",
                           "MoL",
                           "MethodOfLines",
                           "Ensure the correct time and timestep are used - initial",
                           "CCTK_INITIAL",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_PreStep",
"MoL_PreStep",
                        "MoL",
                        "MethodOfLines",
                        "Physics thorns can schedule preloop setup routines in here",
                        "MoL_Evolution",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        1,  /* Number of BEFORE  routines  */
                        1,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL_Step",
                        "MoL_StartStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_InitialCopy,
                           "MoL_InitialCopy",
                           "MoL",
                           "MethodOfLines",
                           "Ensure the data is in the correct timelevel",
                           "MoL_Evolution",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_Step",
                           "MoL_PreStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_Step",
"MoL_Step",
                        "MoL",
                        "MethodOfLines",
                        "The loop over the intermediate steps for the ODE integrator",
                        "MoL_Evolution",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        1,  /* Number of AFTER   routines  */
                        1,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL_PreStep",
                        "MoL::MoL_Intermediate_Step");
  }
if (CCTK_Equals(ODE_Method,"ICN-avg")) 
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_ICNAverage,
                           "MoL_Prepare",
                           "MoL",
                           "MethodOfLines",
                           "Averages the time levels for the averaging ICN method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_CalcRHS");
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_InitRHS,
                           "MoL_InitRHS",
                           "MoL",
                           "MethodOfLines",
                           "Initialise the RHS functions",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_CalcRHS");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_CalcRHS",
"MoL_CalcRHS",
                        "MoL",
                        "MethodOfLines",
                        "Physics thorns schedule the calculation of the discrete spatial operator in here",
                        "MoL_Step",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_PostRHS",
"MoL_PostRHS",
                        "MoL",
                        "MethodOfLines",
                        "Modify RHS functions",
                        "MoL_Step",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        2,  /* Number of BEFORE  routines  */
                        1,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL_NaNCheck",
                        "MoL_Add",
                        "MoL_CalcRHS");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_RHSBoundaries",
"MoL_RHSBoundaries",
                        "MoL",
                        "MethodOfLines",
                        "Any 'final' modifications to the RHS functions (boundaries etc.)",
                        "MoL_Step",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        2,  /* Number of BEFORE  routines  */
                        1,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL_NaNCheck",
                        "MoL_Add",
                        "MoL_PostRHS");
  }
if (MoL_NaN_Check)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_NaNCheck,
                           "MoL_NaNCheck",
                           "MoL",
                           "MethodOfLines",
                           "Check the RHS GFs for NaNs",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_Add",
                           "MoL_CalcRHS");
  }
}
if (CCTK_Equals(ODE_Method,"Generic"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_GenericRKAdd,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with a generic method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
else if (CCTK_Equals(ODE_Method,"RK2")) 
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_RK2Add,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with the efficient Runge-Kutta 2 method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
else if (CCTK_Equals(ODE_Method,"RK3")) 
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_RK3Add,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with the efficient Runge-Kutta 3 method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
else if (CCTK_Equals(ODE_Method,"RK4"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_RK4Add,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with the efficient Runge-Kutta 4 method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
else if (CCTK_Equals(ODE_Method,"RK45") || CCTK_Equals(ODE_Method,"RK45CK"))
{
  CCTKi_ScheduleGroupStorage("MoL::ErrorEstimate",1);
  CCTKi_ScheduleGroupStorage("MoL::ErrorScalars",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_RK45Add,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with the Runge-Kutta 45 method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
else if (CCTK_Equals(ODE_Method,"RK65")) 
{
  CCTKi_ScheduleGroupStorage("MoL::ErrorEstimate",1);
  CCTKi_ScheduleGroupStorage("MoL::ErrorScalars",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_RK65Add,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with the Runge-Kutta 65 method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
else if (CCTK_Equals(ODE_Method,"RK87")) 
{
  CCTKi_ScheduleGroupStorage("MoL::ErrorEstimate",1);
  CCTKi_ScheduleGroupStorage("MoL::ErrorScalars",1);
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_RK87Add,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with the Runge-Kutta 87 method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
else if (CCTK_Equals(ODE_Method,"ICN"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_ICNAdd,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with the efficient ICN method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
else if (CCTK_Equals(ODE_Method,"ICN-avg"))
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_ICNAdd,
                           "MoL_Add",
                           "MoL",
                           "MethodOfLines",
                           "Updates calculated with the averaging ICN method",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_PostStep",
                           "MoL_CalcRHS");
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_PostStep",
"MoL_PostStep",
                        "MoL",
                        "MethodOfLines",
                        "The group for physics thorns to schedule boundary calls etc.",
                        "MoL_Step",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        1,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                        "MoL_Add");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_PostStep",
"MoL_PostStep",
                        "MoL",
                        "MethodOfLines",
                        "Ensure that everything is correct after the initial data have been set up",
                        "CCTK_POSTINITIAL",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_PostStep",
"MoL_PostStep",
                        "MoL",
                        "MethodOfLines",
                        "Ensure that everything is correct after regridding",
                        "CCTK_POSTREGRID",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_PostStep",
"MoL_PostStep",
                        "MoL",
                        "MethodOfLines",
                        "Ensure that everything is correct after restriction",
                        "CCTK_POSTRESTRICT",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_OldBdry_Wrap",
"MoL_OldBdry_Wrap",
                        "MoL",
                        "MethodOfLines",
                        "Wrapper group, do not schedule directly into this group",
                        "MoL_PostStep",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleGroup("MoL_OldStyleBoundaries",
"MoL_OldStyleBoundaries",
                        "MoL",
                        "MethodOfLines",
                        "Place old style boundary routines here",
                        "MoL_OldBdry_Wrap",
                        0,  /* Number of STORAGE  groups   */
                        0,  /* Number of COMM     groups   */
                        0,  /* Number of TRIGGERS groups   */
                        0,  /* Number of SYNC     groups   */
                        0,  /* Number of Options           */
                        0,  /* Number of BEFORE  routines  */
                        0,  /* Number of AFTER   routines  */
                        0,  /* Number of WHILE   variables */
                        0,  /* Number of IF   variables */
                        cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */);
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_OldBdry_SetDt,
                           "MoL_OldBdry_SetDt",
                           "MoL",
                           "MethodOfLines",
                           "Store and change dt",
                           "MoL_OldBdry_Wrap",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_OldStyleBoundaries");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_OldBdry_ResetDt,
                           "MoL_OldBdry_ResetDt",
                           "MoL",
                           "MethodOfLines",
                           "Reset dt",
                           "MoL_OldBdry_Wrap",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_OldStyleBoundaries");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_DecrementCounter,
                           "MoL_DecrementCounter",
                           "MoL",
                           "MethodOfLines",
                           "Alter the counter number",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_PostStep",
                           "MoL_Add");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_ResetTime,
                           "MoL_ResetTime",
                           "MoL",
                           "MethodOfLines",
                           "If necessary, change the time",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_PostStep",
                           "MoL_DecrementCounter");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_ResetDeltaTime,
                           "MoL_ResetDeltaTime",
                           "MoL",
                           "MethodOfLines",
                           "If necessary, change the timestep",
                           "MoL_Step",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_RestoreSandR,
                           "MoL_RestoreSandR",
                           "MoL",
                           "MethodOfLines",
                           "Restoring the Save and Restore variables to the original state",
                           "MoL_Evolution",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_FinishLoop");
  }
if (adaptive_stepsize)
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_InitAdaptiveError,
                           "MoL_InitAdaptiveError",
                           "MoL",
                           "MethodOfLines",
                           "Control the step size: initialize error check variables",
                           "MoL_Evolution",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_PostStep");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_FindAdaptiveError,
                           "MoL_FindAdaptiveError",
                           "MoL",
                           "MethodOfLines",
                           "Control the step size: compute error check variables",
                           "MoL_Evolution",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "MoL_InitAdaptiveError");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_ReduceAdaptiveError,
                           "MoL_ReduceAdaptiveError",
                           "MoL",
                           "MethodOfLines",
                           "Control the step size: reduce error check variables",
                           "MoL_Evolution",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_FindAdaptiveError");
  }
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_SetEstimatedDt,
                           "MoL_SetEstimatedDt",
                           "MoL",
                           "MethodOfLines",
                           "Control the step size: set the new timestep",
                           "CCTK_POSTSTEP",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL");
  }
}
else
{
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_FinishLoop,
                           "MoL_FinishLoop",
                           "MoL",
                           "MethodOfLines",
                           "Control the step size",
                           "MoL_Evolution",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           1,  /* Number of Options           */
                           0,  /* Number of BEFORE  routines  */
                           1,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "LEVEL",
                           "MoL_Step");
  }
}
  {
    int cctkschedulei_tlevelarray[] = {0};
    CCTKi_ScheduleFunction((void *)MoL_FreeIndexArrays,
                           "MoL_FreeIndexArrays",
                           "MoL",
                           "MethodOfLines",
                           "Free the MoL bookkeeping index arrays",
                           "CCTK_TERMINATE",
                           "C",
                           0,  /* Number of STORAGE  groups   */
                           0,  /* Number of COMM     groups   */
                           0,  /* Number of TRIGGERS groups   */
                           0,  /* Number of SYNC     groups   */
                           0,  /* Number of Options           */
                           1,  /* Number of BEFORE  routines  */
                           0,  /* Number of AFTER   routines  */
                           0,  /* Number of WHILE   variables */
                           0,  /* Number of IF   variables */
                           cctkschedulei_tlevelarray  /* Array of timelevel data for storage groups */,
                           "Driver_Terminate");
  }
}

/*@@
  @routine    CCTKi_BindingsParameterRecovery_MoL
  @author     Automatically generated by CreateScheduleBindings.pl
  @desc
              Creates the parameter recovery bindings for thorn MoL
  @enddesc
@@*/

int CCTKi_BindingsParameterRecovery_MoL(void);
int CCTKi_BindingsParameterRecovery_MoL(void)
{
  /* this thorn doesn't define any parameter recovery routines */
  return (0);
}

