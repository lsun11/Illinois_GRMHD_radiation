/*@@
   @file    ahfinderdirect_Parameters.c
   @author  Automatically generated by CreateParameterBindings.pl
   @desc
            Creates/extends parameters for this thorn
   @enddesc
 @@*/


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include "cctk_Config.h"
#include "cctk_Constants.h"
#include "ParameterBindings.h"
#include "CParameterStructNames.h"
#include "ParameterCRestrictedGRID.h"
#include "ParameterCRestrictedIO.h"
#include "ParameterCRestrictedSPACEMASK.h"
#include "ParameterCRestrictedSPHERICALSURFACE.h"

/* structure containing all private parameters of thorn ahfinderdirect */
struct
{
  CCTK_REAL ILUCG__error_tolerance;
  CCTK_REAL Jacobian_perturbation_amplitude;
  CCTK_REAL Theta_norm_for_convergence;
  CCTK_REAL desired_value[101];
  CCTK_REAL desired_value_factor[101];
  CCTK_REAL desired_value_offset[101];
  CCTK_REAL dont_find_after_individual_time[101];
  CCTK_REAL find_after_individual_time[101];
  CCTK_REAL geometry__Schwarzschild_EF__Delta_xyz;
  CCTK_REAL geometry__Schwarzschild_EF__epsilon;
  CCTK_REAL geometry__Schwarzschild_EF__mass;
  CCTK_REAL geometry__Schwarzschild_EF__x_posn;
  CCTK_REAL geometry__Schwarzschild_EF__y_posn;
  CCTK_REAL geometry__Schwarzschild_EF__z_posn;
  CCTK_REAL mask_buffer_thickness;
  CCTK_REAL mask_radius_multiplier;
  CCTK_REAL mask_radius_offset;
  CCTK_REAL max_allowable_Delta_h_over_h;
  CCTK_REAL max_allowable_Theta;
  CCTK_REAL max_allowable_horizon_radius[101];
  CCTK_REAL min_horizon_radius_points_for_mask;
  CCTK_REAL old_style_mask_buffer_value;
  CCTK_REAL old_style_mask_inside_value;
  CCTK_REAL old_style_mask_outside_value;
  CCTK_REAL pretracking_delta[101];
  CCTK_REAL pretracking_maximum_delta[101];
  CCTK_REAL pretracking_maximum_value[101];
  CCTK_REAL pretracking_minimum_delta[101];
  CCTK_REAL pretracking_minimum_value[101];
  CCTK_REAL pretracking_value[101];
  CCTK_REAL shiftout_factor[101];
  CCTK_REAL smoothing_factor[101];
  const char * ASCII_gnuplot_file_name_extension;
  const char * BH_diagnostics_base_file_name;
  const char * BH_diagnostics_directory;
  const char * BH_diagnostics_file_name_extension;
  const char * Delta_h_base_file_name;
  const char * HDF5_file_name_extension;
  const char * Jacobian_base_file_name;
  const char * Jacobian_compute_method;
  const char * Jacobian_store_solve_method;
  const char * OpenDX_control_file_name_extension;
  const char * Theta_base_file_name;
  const char * coordinate_system_name;
  const char * geometry_interpolator_name;
  const char * geometry_interpolator_pars;
  const char * h_base_file_name;
  const char * h_directory;
  const char * integral_method;
  const char * interpatch_interpolator_name;
  const char * interpatch_interpolator_pars;
  const char * mean_curvature_base_file_name;
  const char * method;
  const char * metric_type;
  const char * new_style_mask_bitfield_name;
  const char * new_style_mask_buffer_value;
  const char * new_style_mask_gridfn_name;
  const char * new_style_mask_inside_value;
  const char * new_style_mask_outside_value;
  const char * old_style_mask_gridfn_name;
  const char * patch_system_type[101];
  const char * surface_definition[101];
  const char * surface_interpolator_name;
  const char * surface_interpolator_pars;
  const char * surface_modification[101];
  const char * surface_selection[101];
  const char * verbose_level;
  CCTK_INT ILUCG__limit_CG_iterations;
  CCTK_INT N_horizons;
  CCTK_INT N_zones_per_right_angle[101];
  CCTK_INT UMFPACK__N_II_iterations;
  CCTK_INT check_that_geometry_is_finite;
  CCTK_INT check_that_h_is_finite;
  CCTK_INT debugging_output_at_each_Newton_iteration;
  CCTK_INT depends_on[101];
  CCTK_INT disable_horizon[101];
  CCTK_INT dont_find_after_individual[101];
  CCTK_INT find_after_individual[101];
  CCTK_INT find_every;
  CCTK_INT find_every_individual[101];
  CCTK_INT ghost_zone_width;
  CCTK_INT h_min_digits;
  CCTK_INT hardwire_Schwarzschild_EF_geometry;
  CCTK_INT mask_is_noshrink;
  CCTK_INT max_N_zones_per_right_angle;
  CCTK_INT max_Newton_iterations__initial;
  CCTK_INT max_Newton_iterations__subsequent;
  CCTK_INT max_allowable_Theta_growth_iterations;
  CCTK_INT max_allowable_Theta_nonshrink_iterations;
  CCTK_INT output_ASCII_files;
  CCTK_INT output_BH_diagnostics;
  CCTK_INT output_HDF5_files;
  CCTK_INT output_OpenDX_control_files;
  CCTK_INT output_Theta_every;
  CCTK_INT output_ghost_zones_for_h;
  CCTK_INT output_h_every;
  CCTK_INT output_initial_guess;
  CCTK_INT output_mean_curvature_every;
  CCTK_INT patch_overlap_width;
  CCTK_INT pretracking_max_iterations[101];
  CCTK_INT print_timing_stats;
  CCTK_INT run_at_CCTK_ANALYSIS;
  CCTK_INT run_at_CCTK_POSTINITIAL;
  CCTK_INT run_at_CCTK_POSTSTEP;
  CCTK_INT run_at_CCTK_POST_RECOVER_VARIABLES;
  CCTK_INT set_mask_for_all_horizons;
  CCTK_INT set_mask_for_individual_horizon[101];
  CCTK_INT set_new_style_mask;
  CCTK_INT set_old_style_mask;
  CCTK_INT test_all_Jacobian_compute_methods;
  CCTK_INT use_pretracking[101];
  CCTK_INT want_expansion_gradients;
  CCTK_INT warn_level__gij_not_positive_definite__initial;
  CCTK_INT warn_level__gij_not_positive_definite__subsequent;
  CCTK_INT warn_level__nonfinite_geometry;
  CCTK_INT warn_level__point_outside__initial;
  CCTK_INT warn_level__point_outside__subsequent;
  CCTK_INT warn_level__skipping_finite_check;
  CCTK_INT which_horizon_to_announce_centroid;
  CCTK_INT which_surface_to_store_info[101];
} PRIVATE_AHFINDERDIRECT_STRUCT;


/* structure containing all restricted parameters of thorn ahfinderdirect */
struct
{
  CCTK_REAL initial_guess__Kerr_KerrSchild__mass[101];
  CCTK_REAL initial_guess__Kerr_KerrSchild__spin[101];
  CCTK_REAL initial_guess__Kerr_KerrSchild__x_posn[101];
  CCTK_REAL initial_guess__Kerr_KerrSchild__y_posn[101];
  CCTK_REAL initial_guess__Kerr_KerrSchild__z_posn[101];
  CCTK_REAL initial_guess__Kerr_Kerr__mass[101];
  CCTK_REAL initial_guess__Kerr_Kerr__spin[101];
  CCTK_REAL initial_guess__Kerr_Kerr__x_posn[101];
  CCTK_REAL initial_guess__Kerr_Kerr__y_posn[101];
  CCTK_REAL initial_guess__Kerr_Kerr__z_posn[101];
  CCTK_REAL initial_guess__coord_ellipsoid__x_center[101];
  CCTK_REAL initial_guess__coord_ellipsoid__x_radius[101];
  CCTK_REAL initial_guess__coord_ellipsoid__y_center[101];
  CCTK_REAL initial_guess__coord_ellipsoid__y_radius[101];
  CCTK_REAL initial_guess__coord_ellipsoid__z_center[101];
  CCTK_REAL initial_guess__coord_ellipsoid__z_radius[101];
  CCTK_REAL initial_guess__coord_sphere__radius[101];
  CCTK_REAL initial_guess__coord_sphere__x_center[101];
  CCTK_REAL initial_guess__coord_sphere__y_center[101];
  CCTK_REAL initial_guess__coord_sphere__z_center[101];
  CCTK_REAL origin_x[101];
  CCTK_REAL origin_y[101];
  CCTK_REAL origin_z[101];
  const char * initial_guess__read_from_named_file__file_name[101];
  const char * initial_guess_method[101];
  CCTK_INT move_origins;
  CCTK_INT predict_origin_movement;
  CCTK_INT reset_horizon_after_not_finding[101];
  CCTK_INT reshape_while_moving;
} RESTRICTED_AHFINDERDIRECT_STRUCT;


int CCTKi_BindingsCreateahfinderdirectParameters(void);
int CCTKi_BindingsCreateahfinderdirectParameters(void)
{
  CCTKi_ParameterCreate("initial_guess__Kerr_KerrSchild__mass",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "mass of Kerr BH",
                        "1.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_KerrSchild__mass),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "BH mass = any real number > 0");

  CCTKi_ParameterCreate("initial_guess__Kerr_KerrSchild__spin",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "dimensionless spin a=J/m^2 of Kerr BH",
                        "0.6",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_KerrSchild__spin),
                        101,
                        NULL,
                        1,
                        "(-1.0:1.0)",   "dimensionless BH spin = J/m^2 = any real number with absolute value < 1");

  CCTKi_ParameterCreate("initial_guess__Kerr_KerrSchild__x_posn",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "x coordinate of Kerr BH",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_KerrSchild__x_posn),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__Kerr_KerrSchild__y_posn",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "y coordinate of Kerr BH",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_KerrSchild__y_posn),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__Kerr_KerrSchild__z_posn",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "z coordinate of Kerr BH",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_KerrSchild__z_posn),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__Kerr_Kerr__mass",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "mass of Kerr BH",
                        "1.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_Kerr__mass),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "BH mass = any real number > 0");

  CCTKi_ParameterCreate("initial_guess__Kerr_Kerr__spin",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "dimensionless spin a=J/m^2 of Kerr BH",
                        "0.6",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_Kerr__spin),
                        101,
                        NULL,
                        1,
                        "(-1.0:1.0)",   "dimensionless BH spin = J/m^2 = any real number with absolute value < 1");

  CCTKi_ParameterCreate("initial_guess__Kerr_Kerr__x_posn",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "x coordinate of Kerr BH",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_Kerr__x_posn),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__Kerr_Kerr__y_posn",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "y coordinate of Kerr BH",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_Kerr__y_posn),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__Kerr_Kerr__z_posn",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "z coordinate of Kerr BH",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__Kerr_Kerr__z_posn),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__coord_ellipsoid__x_center",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "x coordinate of ellipsoid center",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_ellipsoid__x_center),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__coord_ellipsoid__x_radius",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "x radius of ellipsoid",
                        "2.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_ellipsoid__x_radius),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "any real number > 0.0");

  CCTKi_ParameterCreate("initial_guess__coord_ellipsoid__y_center",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "y coordinate of ellipsoid center",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_ellipsoid__y_center),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__coord_ellipsoid__y_radius",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "y radius of ellipsoid",
                        "2.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_ellipsoid__y_radius),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "any real number > 0.0");

  CCTKi_ParameterCreate("initial_guess__coord_ellipsoid__z_center",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "z coordinate of ellipsoid center",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_ellipsoid__z_center),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__coord_ellipsoid__z_radius",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "z radius of ellipsoid",
                        "2.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_ellipsoid__z_radius),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "any real number > 0.0");

  CCTKi_ParameterCreate("initial_guess__coord_sphere__radius",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "radius of sphere",
                        "2.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_sphere__radius),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "any real number > 0.0");

  CCTKi_ParameterCreate("initial_guess__coord_sphere__x_center",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "x coordinate of sphere center",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_sphere__x_center),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__coord_sphere__y_center",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "y coordinate of sphere center",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_sphere__y_center),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__coord_sphere__z_center",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "z coordinate of sphere center",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__coord_sphere__z_center),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("initial_guess__read_from_named_file__file_name",
                        "ahfinderdirect",
                        "STRING",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "file name to read initial guess from",
                        "h.gp",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess__read_from_named_file__file_name),
                        101,
                        NULL,
                        1,
                        ".+", "file name to read initial guess from");

  CCTKi_ParameterCreate("initial_guess_method",
                        "ahfinderdirect",
                        "KEYWORD",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "method used to set up initial guess for apparent horizon shape",
                        "coordinate sphere",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.initial_guess_method),
                        101,
                        NULL,
                        6,
                        "read from named file", "read from explicitly-named input file",
                        "read from h file",   "read from input file named the same as the (later) h output file",
                        "Kerr/Kerr",   "set to the (analytical) horizon of Kerr spacetime in Kerr coordinates    (n.b. Schwarzschild/EF is the special case spin=0 of this)",
                        "Kerr/Kerr-Schild",   "set to the (analytical) horizon of Kerr spacetime in Kerr-Schild coordinates",
                        "coordinate sphere", "set to a coordinate sphere",
                        "coordinate ellipsoid", "set to a coordinate ellipsoid");

  CCTKi_ParameterCreate("move_origins",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "move the origins with the horizons",
                        "no",
                        &(RESTRICTED_AHFINDERDIRECT_STRUCT.move_origins),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("origin_x",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "global x coordinate of patch system origin",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.origin_x),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("origin_y",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "global y coordinate of patch system origin",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.origin_y),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("origin_z",
                        "ahfinderdirect",
                        "REAL",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "global z coordinate of patch system origin",
                        "0.0",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.origin_z),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("predict_origin_movement",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "predict origin movement when moving the origins",
                        "no",
                        &(RESTRICTED_AHFINDERDIRECT_STRUCT.predict_origin_movement),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("reset_horizon_after_not_finding",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "reset the horizon shape to the initial data if a horizon was not found",
                        "yes",
                        (RESTRICTED_AHFINDERDIRECT_STRUCT.reset_horizon_after_not_finding),
                        101,
                        NULL,
                        0);

  CCTKi_ParameterCreate("reshape_while_moving",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "RESTRICTED",
                        CCTK_STEERABLE_RECOVER,
                        "reshape the horizons when moving them",
                        "no",
                        &(RESTRICTED_AHFINDERDIRECT_STRUCT.reshape_while_moving),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("ASCII_gnuplot_file_name_extension",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "extension for ASCII (gnuplot) data files",
                        "gp",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.ASCII_gnuplot_file_name_extension),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("BH_diagnostics_base_file_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "base file name for BH diagnostics output file(s)",
                        "BH_diagnostics",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.BH_diagnostics_base_file_name),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("BH_diagnostics_directory",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "directory for BH diagnostics output file(s)",
                        "",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.BH_diagnostics_directory),
                        0,
                        NULL,
                        2,
                        ".+", "any nonempty string",
                        "^$", "an empty string to default to IO::out_dir");

  CCTKi_ParameterCreate("BH_diagnostics_file_name_extension",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "extension for BH diagnostics data files",
                        "gp",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.BH_diagnostics_file_name_extension),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("Delta_h_base_file_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "base file name for horizon-shape-update Delta_h output file(s)",
                        "Delta_h",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.Delta_h_base_file_name),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("HDF5_file_name_extension",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "extension for HDF5 data files",
                        "h5",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.HDF5_file_name_extension),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("ILUCG__error_tolerance",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "error tolerance for conjugate gradient iteration",
                        "1.0e-10",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.ILUCG__error_tolerance),
                        0,
                        NULL,
                        2,
                        "(*:0.0)",   "negative ==> scale the absolute value by the floating point roundoff                 threshold, e.g. -256.0 means to allow the last 8 bits of                 the solution to be in error",
                        "(0.0:*)",   "positive ==> error tolerance");

  CCTKi_ParameterCreate("ILUCG__limit_CG_iterations",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we limit the maximum number of conjugate gradient iterations allowed?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.ILUCG__limit_CG_iterations),
                        0,
                        NULL,
                        2,
                        "false", "no limit on CG iterations",
                        "true", "limit to Neqns CG iterations");

  CCTKi_ParameterCreate("Jacobian_base_file_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "base file name for Jacobian output file(s)",
                        "Jacobian.dat",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.Jacobian_base_file_name),
                        0,
                        NULL,
                        1,
                        ".+", "any valid file name");

  CCTKi_ParameterCreate("Jacobian_compute_method",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "how do we compute the Jacobian matrix?",
                        "symbolic differentiation with finite diff d/dr",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.Jacobian_compute_method),
                        0,
                        NULL,
                        3,
                        "numerical perturbation", "n.b. this is *very* slow",
                        "symbolic differentiation with finite diff d/dr",   "fast, tricky programming, uses only gij, dx gij, Kij",
                        "symbolic differentiation",   "fast, tricky programming, uses gij, dx gij, dxx gij, Kij, dx Kij");

  CCTKi_ParameterCreate("Jacobian_perturbation_amplitude",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "perturbation amplitude for 1-sided finite differencing for Jacobians",
                        "1.0e-6",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.Jacobian_perturbation_amplitude),
                        0,
                        NULL,
                        1,
                        "(0.0:*", "any real number > 0");

  CCTKi_ParameterCreate("Jacobian_store_solve_method",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "how do we store/linear-solve the Jacobian matrix?",
                        "row-oriented sparse matrix/UMFPACK",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.Jacobian_store_solve_method),
                        0,
                        NULL,
                        3,
                        "dense matrix/LAPACK",   "store as (Fortran) dense matrix, solve with LAPACK routines",
                        "row-oriented sparse matrix/ILUCG",   "store as sparse matrix (row-oriented storage format),    solve with ILUCG (incomplete LU decomposition - conjugate gradient) method",
                        "row-oriented sparse matrix/UMFPACK",   "store as sparse matrix (row-oriented storage format),    solve with UMFPACK (sparse LU decomposition) method");

  CCTKi_ParameterCreate("N_horizons",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "number of apparent horizons to search for",
                        "1",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.N_horizons),
                        0,
                        NULL,
                        2,
                        "0", "turn this thorn into a fancy no-op :)",
                        "1:100", "search for this many apparent horizons");

  CCTKi_ParameterCreate("N_zones_per_right_angle",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "sets angular resolution of patch systems",
                        "18",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.N_zones_per_right_angle),
                        101,
                        NULL,
                        1,
                        "1:*", "any integer >= 1; must be even for patch systems other than full-sphere");

  CCTKi_ParameterCreate("OpenDX_control_file_name_extension",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "file name extension for OpenDX control files",
                        "dx",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.OpenDX_control_file_name_extension),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("Theta_base_file_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "base file name for Theta(h) output file(s)",
                        "Theta",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.Theta_base_file_name),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("Theta_norm_for_convergence",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "we declare the horizon to be found if ||Theta||_infinity <= this",
                        "1.0e-8",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.Theta_norm_for_convergence),
                        0,
                        NULL,
                        1,
                        "(0.0:*", "any positive real number");

  CCTKi_ParameterCreate("UMFPACK__N_II_iterations",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "number of iterative-improvement iterations to do inside UMFPACK    after the sparse LU decompose/solve, each time we solve a linear system",
                        "0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.UMFPACK__N_II_iterations),
                        0,
                        NULL,
                        3,
                        "-1", "use the UMFPACK default",
                        "0", "don't do iterative improvement",
                        "1:*", "any positive integer 	    (in practice a few iterations give almost all the benefit)");

  CCTKi_ParameterCreate("check_that_geometry_is_finite",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we check the interpolated geometry variables are finite?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.check_that_geometry_is_finite),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("check_that_h_is_finite",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we check that horizon shape function h is finite?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.check_that_h_is_finite),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("coordinate_system_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "name under which the coordinate system is registered in Cactus",
                        "cart3d",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.coordinate_system_name),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("debugging_output_at_each_Newton_iteration",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we output {h, Theta, delta_h} at each Newton iteration?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.debugging_output_at_each_Newton_iteration),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("depends_on",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "the other horizon that this horizon depends on",
                        "0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.depends_on),
                        101,
                        NULL,
                        2,
                        "0", "the horizon is independent",
                        "1:100", "horizon index");

  CCTKi_ParameterCreate("desired_value",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "search for a surface with this (constant) value",
                        "0.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.desired_value),
                        101,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("desired_value_factor",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "factor between this horizon's and the other horizon's desired value, applied before the offset",
                        "1.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.desired_value_factor),
                        101,
                        NULL,
                        1,
                        "*:*", "");

  CCTKi_ParameterCreate("desired_value_offset",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "difference between this horizon's and the other horizon's desired value, applied after the factor",
                        "0.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.desired_value_offset),
                        101,
                        NULL,
                        1,
                        "*:*", "");

  CCTKi_ParameterCreate("disable_horizon",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "should this horizon be disabled?",
                        "false",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.disable_horizon),
                        101,
                        NULL,
                        0);

  CCTKi_ParameterCreate("dont_find_after_individual",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "when should we stop finding individual apparent horizons?",
                        "-1",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.dont_find_after_individual),
                        101,
                        NULL,
                        2,
                        "0:*", "after this iteration (exclusively)",
                        "-1", "do not use this parameter");

  CCTKi_ParameterCreate("dont_find_after_individual_time",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "when should we stop finding individual apparent horizons?",
                        "0.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.dont_find_after_individual_time),
                        101,
                        NULL,
                        1,
                        "*:*", "after this time (exclusively); ignore this value if it is less than or equal to find_after_individual_time");

  CCTKi_ParameterCreate("find_after_individual",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "when should we start to find individual apparent horizons?",
                        "0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.find_after_individual),
                        101,
                        NULL,
                        1,
                        "0:*", "after this iteration (inclusively)");

  CCTKi_ParameterCreate("find_after_individual_time",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "when should we start to find individual apparent horizons?",
                        "0.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.find_after_individual_time),
                        101,
                        NULL,
                        1,
                        "*:*", "after this time (inclusively)");

  CCTKi_ParameterCreate("find_every",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "how often should we try to find apparent horizons?",
                        "1",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.find_every),
                        0,
                        NULL,
                        2,
                        "0", "don't find AHs at all (this thorn is a no-op)",
                        "1:*", "any integer >= 1");

  CCTKi_ParameterCreate("find_every_individual",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "how often should we try to find individual apparent horizons?  (overrides find_every)",
                        "-1",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.find_every_individual),
                        101,
                        NULL,
                        3,
                        "-1", "use the value of find_every",
                        "0", "don't find this AH at all",
                        "1:*", "any integer >= 1");

  CCTKi_ParameterCreate("geometry__Schwarzschild_EF__Delta_xyz",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "finite diff pseuo-grid spacing for computing partial_k g_ij",
                        "1.0e-6",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.geometry__Schwarzschild_EF__Delta_xyz),
                        0,
                        NULL,
                        1,
                        "(0.0:*", "any real number > 0");

  CCTKi_ParameterCreate("geometry__Schwarzschild_EF__epsilon",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "threshold for sin^2 theta = (x^2+y^2)/r^2 below which we use z axis limits",
                        "1.0e-9",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.geometry__Schwarzschild_EF__epsilon),
                        0,
                        NULL,
                        1,
                        "(0.0:*", "this should be somewhat above the floating-point roundoff level");

  CCTKi_ParameterCreate("geometry__Schwarzschild_EF__mass",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "mass of Schwarzschild BH",
                        "1.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.geometry__Schwarzschild_EF__mass),
                        0,
                        NULL,
                        1,
                        "(0.0:*", "BH mass = any real number > 0");

  CCTKi_ParameterCreate("geometry__Schwarzschild_EF__x_posn",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "x coordinate of Schwarzschild BH",
                        "0.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.geometry__Schwarzschild_EF__x_posn),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("geometry__Schwarzschild_EF__y_posn",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "y coordinate of Schwarzschild BH",
                        "0.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.geometry__Schwarzschild_EF__y_posn),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("geometry__Schwarzschild_EF__z_posn",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "z coordinate of Schwarzschild BH",
                        "0.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.geometry__Schwarzschild_EF__z_posn),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("geometry_interpolator_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "name under which the geometry interpolation operator is registered in Cactus",
                        "Hermite polynomial interpolation",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.geometry_interpolator_name),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("geometry_interpolator_pars",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "parameters for the geometry interpolator",
                        "order=2    boundary_off_centering_tolerance={1.0e-10 1.0e-10 1.0e-10 1.0e-10 1.0e-10 1.0e-10}    boundary_extrapolation_tolerance={0.0 0.0 0.0 0.0 0.0 0.0}",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.geometry_interpolator_pars),
                        0,
                        NULL,
                        1,
                        ".*",   "any string acceptable to Util_TableSetFromString() and to the interpolator");

  CCTKi_ParameterCreate("ghost_zone_width",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "number of ghost zones on each side of a patch",
                        "2",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.ghost_zone_width),
                        0,
                        NULL,
                        1,
                        "0:*", "any integer >= 0");

  CCTKi_ParameterCreate("h_base_file_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "base file name for horizon shape h input/output file(s)",
                        "h",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.h_base_file_name),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("h_directory",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "directory for horizon shape and other similar output (or input) file(s)",
                        "",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.h_directory),
                        0,
                        NULL,
                        2,
                        ".+", "any nonempty string",
                        "^$", "an empty string to default to IO::out_dir");

  CCTKi_ParameterCreate("h_min_digits",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "minimum number of digits for the iteration number in the file name",
                        "0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.h_min_digits),
                        0,
                        NULL,
                        1,
                        "0:*", "");

  CCTKi_ParameterCreate("hardwire_Schwarzschild_EF_geometry",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "should we hard-wire the geometry to Schwarzschild/EF instead of    interpolating from the Cactus grid?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.hardwire_Schwarzschild_EF_geometry),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("integral_method",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "how do we compute integrals over the horizon?",
                        "automatic choice",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.integral_method),
                        0,
                        NULL,
                        7,
                        "trapezoid", "alternate name for trapezoid rule",
                        "trapezoid rule", "trapezoid rule (2nd order for smooth functions)",
                        "Simpson", "alternate name for Simpson's rule",
                        "Simpson's rule",   "Simpson's rule (4th order for smooth fns, requires N to be even)",
                        "Simpson (variant)", "alternate name for Simpson's rule variant",
                        "Simpson's rule (variant)",   "Simpson's rule variant (4th order for smooth fns, requires N >= 7)",
                        "automatic choice",   "choose Simpson's rule or variant if applicable, otherwise trapezoid rule");

  CCTKi_ParameterCreate("interpatch_interpolator_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "name under which the interpatch interpolation operator is registered in Cactus",
                        "Lagrange polynomial interpolation",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.interpatch_interpolator_name),
                        0,
                        NULL,
                        1,
                        ".+", "any string (in practice it should be nonempty)");

  CCTKi_ParameterCreate("interpatch_interpolator_pars",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "parameters for the interpatch interpolator",
                        "order=5",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.interpatch_interpolator_pars),
                        0,
                        NULL,
                        1,
                        ".*",   "any string acceptable to Util_TableSetFromString() and to the interpolator");

  CCTKi_ParameterCreate("mask_buffer_thickness",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "thickness (in Cactus base grid spacings) of the 'buffer' mask region",
                        "5.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.mask_buffer_thickness),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number; typically this will be positive");

  CCTKi_ParameterCreate("mask_is_noshrink",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we prevent the inside & buffer regions from ever shrinking?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.mask_is_noshrink),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("mask_radius_multiplier",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "radius multiplier to define the 'inside' mask region",
                        "1.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.mask_radius_multiplier),
                        0,
                        NULL,
                        1,
                        "(0:*)",   "any positive real number; typically this will be slightly less than 1.0");

  CCTKi_ParameterCreate("mask_radius_offset",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "radius offset (in Cactus base grid spacings) to define the 'inside' mask region",
                        "-5.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.mask_radius_offset),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number; typically this will be negative");

  CCTKi_ParameterCreate("max_N_zones_per_right_angle",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "the maximum of all N_zones_per_right_angle",
                        "18",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.max_N_zones_per_right_angle),
                        0,
                        NULL,
                        1,
                        "1:*", "must be at least the maximum of all N_zones_per_right_angle");

  CCTKi_ParameterCreate("max_Newton_iterations__initial",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "maximum number of Newton iterations before giving up    when initially finding a given horizon",
                        "20",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.max_Newton_iterations__initial),
                        0,
                        NULL,
                        1,
                        "(0:*", "any positive integer");

  CCTKi_ParameterCreate("max_Newton_iterations__subsequent",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "maximum number of Newton iterations before giving up    when re-finding a given horizon after finding it before",
                        "10",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.max_Newton_iterations__subsequent),
                        0,
                        NULL,
                        1,
                        "(0:*", "any positive integer");

  CCTKi_ParameterCreate("max_allowable_Delta_h_over_h",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "don't let horizon move > this fraction of mean radius in a Newton iteration",
                        "0.1",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.max_allowable_Delta_h_over_h),
                        0,
                        NULL,
                        1,
                        "(0.0:*", "any positive real number");

  CCTKi_ParameterCreate("max_allowable_Theta",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "max ||Theta||_infinity allowed for any trial surface    before we give up and say we can't find this horizon",
                        "1.0e10",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.max_allowable_Theta),
                        0,
                        NULL,
                        1,
                        "(0.0:*", "any positive real number");

  CCTKi_ParameterCreate("max_allowable_Theta_growth_iterations",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "max number of consecutive iterations during which ||Theta||_infinity    is allowed to grow before we give up and say we can't find this horizon",
                        "0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.max_allowable_Theta_growth_iterations),
                        0,
                        NULL,
                        2,
                        "0", "infinitly many",
                        "1:*", "that many");

  CCTKi_ParameterCreate("max_allowable_Theta_nonshrink_iterations",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "max number of consecutive iterations during which ||Theta||_infinity    is allowed to oscillate without shrinking before we give up and say    we can't find this horizon",
                        "0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.max_allowable_Theta_nonshrink_iterations),
                        0,
                        NULL,
                        2,
                        "0", "infinitly many",
                        "1:*", "that many");

  CCTKi_ParameterCreate("max_allowable_horizon_radius",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "max mean-coordinate-radius allowed for any trial surface    before we give up and say we can't find this horizon",
                        "1.0e10",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.max_allowable_horizon_radius),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "any positive real number");

  CCTKi_ParameterCreate("mean_curvature_base_file_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "base file name for mean_curvature(h) output file(s)",
                        "mean_curvature",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.mean_curvature_base_file_name),
                        0,
                        NULL,
                        1,
                        ".+", "any nonempty string");

  CCTKi_ParameterCreate("method",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "what should this thorn do for each apparent horizon?",
                        "find horizons",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.method),
                        0,
                        NULL,
                        3,
                        "evaluate expansions", "evaluate the LHS function Theta(h)",
                        "test expansion Jacobians",   "compute/print horizon 1's J[Theta(h)] Jacobian matrix (possibly in    multiple ways, depending on the  test_all_Jacobian_methods  parameter)",
                        "find horizons", "find the apparent horizon");

  CCTKi_ParameterCreate("metric_type",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "blah",
                        "static conformal",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.metric_type),
                        0,
                        NULL,
                        1,
                        "static conformal", "metric and extrinsic curvature are the static conformal ones - added by Zach");

  CCTKi_ParameterCreate("min_horizon_radius_points_for_mask",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "only set mask if min r_inner >= this number of local grid spacings",
                        "-1.0e10",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.min_horizon_radius_points_for_mask),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("new_style_mask_bitfield_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "name of the new-style mask bit field ('type') as registered with SpaceMask",
                        "mask",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.new_style_mask_bitfield_name),
                        0,
                        NULL,
                        1,
                        ".+", "any valid bit field ('type') name registered with the SpaceMask thorn");

  CCTKi_ParameterCreate("new_style_mask_buffer_value",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "set the specified bit field of the new-style mask to this named state    at grid points in the 'buffer' region",
                        "buffer",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.new_style_mask_buffer_value),
                        0,
                        NULL,
                        1,
                        ".+", "any state name registered with the SpaceMask thorn");

  CCTKi_ParameterCreate("new_style_mask_gridfn_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "name of the new-style mask grid function",
                        "SpaceMask::space_mask",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.new_style_mask_gridfn_name),
                        0,
                        NULL,
                        1,
                        ".+", "any valid Cactus grid function name");

  CCTKi_ParameterCreate("new_style_mask_inside_value",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "set the specified bit field of the new-style mask to this named state    at grid points in the 'inside' region",
                        "inside",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.new_style_mask_inside_value),
                        0,
                        NULL,
                        1,
                        ".+", "any state name registered with the SpaceMask thorn");

  CCTKi_ParameterCreate("new_style_mask_outside_value",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "set the specified bit field of the new-style mask to this named state    at grid points in the 'outside' region",
                        "outside",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.new_style_mask_outside_value),
                        0,
                        NULL,
                        1,
                        ".+", "any state name registered with the SpaceMask thorn");

  CCTKi_ParameterCreate("old_style_mask_buffer_value",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "set the old-style mask to this value in the 'buffer' region",
                        "0.5",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.old_style_mask_buffer_value),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("old_style_mask_gridfn_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "name of the old-style mask grid function",
                        "SpaceMask::emask",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.old_style_mask_gridfn_name),
                        0,
                        NULL,
                        1,
                        ".+", "any valid Cactus grid function name");

  CCTKi_ParameterCreate("old_style_mask_inside_value",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "set the old-style mask to this value in the 'inside' region",
                        "0.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.old_style_mask_inside_value),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("old_style_mask_outside_value",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "set the old-style mask to this value in the 'outside' region",
                        "1.0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.old_style_mask_outside_value),
                        0,
                        NULL,
                        1,
                        "*:*", "any real number");

  CCTKi_ParameterCreate("output_ASCII_files",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "output h and Theta(h) as ASCII files",
                        "yes",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_ASCII_files),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("output_BH_diagnostics",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "should we output BH diagnostics to a data file for each AH found?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_BH_diagnostics),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("output_HDF5_files",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "output h and Theta(h) as HDF5 files",
                        "no",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_HDF5_files),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("output_OpenDX_control_files",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "should we output OpenDX control files to allow reading of AHFinderDirect    'ASCII (gnuplot)' format data files?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_OpenDX_control_files),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("output_Theta_every",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "how often (in Cactus time steps) should we output the Theta(h) functions?",
                        "0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_Theta_every),
                        0,
                        NULL,
                        2,
                        "0", "don't output Theta(h) at all",
                        "1:*", "any integer >= 1");

  CCTKi_ParameterCreate("output_ghost_zones_for_h",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "should we include the patch system (angular) interpatch ghost zones    in h data files?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_ghost_zones_for_h),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("output_h_every",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "how often (in Cactus time steps) should we output h (0 to disable)?",
                        "1",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_h_every),
                        0,
                        NULL,
                        2,
                        "0", "don't output h at all",
                        "1:*", "any integer >= 1");

  CCTKi_ParameterCreate("output_initial_guess",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "should we output the initial guess back to the h data file?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_initial_guess),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("output_mean_curvature_every",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "how often (in Cactus time steps) should we output the mean_curvature(h) functions?",
                        "0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.output_mean_curvature_every),
                        0,
                        NULL,
                        2,
                        "0", "don't output mean_curvature(h) at all",
                        "1:*", "any integer >= 1");

  CCTKi_ParameterCreate("patch_overlap_width",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "number of grid points that nominally-just-touching patches should overlap",
                        "1",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.patch_overlap_width),
                        0,
                        NULL,
                        1,
                        "1:*:2", "any integer >= 0; current implementation requires that it be odd");

  CCTKi_ParameterCreate("patch_system_type",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "what type of patch system should we use?",
                        "match Cactus grid symmetry",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.patch_system_type),
                        101,
                        NULL,
                        9,
                        "match Cactus grid symmetry",   "choose automagically based on grid symmetries and the patch system's origin",
                        "full sphere", "full sphere, no symmetries",
                        "+z hemisphere", "mirror symmetry across z=0 plane",
                        "+xy quadrant (rotating)", "90 degree periodic rotation symmetry about z axis",
                        "+xy quadrant (mirrored)", "mirror symmetry across x=0 and y=0 planes",
                        "+xz quadrant (mirrored)", "mirror symmetry across x=0 and z=0 planes",
                        "+xz quadrant (rotating)",   "180 degree periodic rotation symmetry about z axis    and mirror symmetry across z=0 plane",
                        "+xyz octant (rotating)",   "90 degree periodic rotation symmetry about z axis    and mirror symmetry across z=0 plane",
                        "+xyz octant (mirrored)", "mirror symmetry across x=0 and y=0 and z=0 planes");

  CCTKi_ParameterCreate("pretracking_delta",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "step size for value",
                        "1.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.pretracking_delta),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "");

  CCTKi_ParameterCreate("pretracking_max_iterations",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "maximum number of pretracking iterations",
                        "100",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.pretracking_max_iterations),
                        101,
                        NULL,
                        1,
                        "0:*", "");

  CCTKi_ParameterCreate("pretracking_maximum_delta",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "maximum step size for value",
                        "1.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.pretracking_maximum_delta),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "");

  CCTKi_ParameterCreate("pretracking_maximum_value",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "maximum pretracking value (should be near the outer boundary)",
                        "10.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.pretracking_maximum_value),
                        101,
                        NULL,
                        1,
                        "*:*", "");

  CCTKi_ParameterCreate("pretracking_minimum_delta",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "minimum step size for value",
                        "1.0e-4",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.pretracking_minimum_delta),
                        101,
                        NULL,
                        1,
                        "(0.0:*", "");

  CCTKi_ParameterCreate("pretracking_minimum_value",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "minimum pretracking value",
                        "0.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.pretracking_minimum_value),
                        101,
                        NULL,
                        1,
                        "*:*", "");

  CCTKi_ParameterCreate("pretracking_value",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "initial pretracking value",
                        "1.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.pretracking_value),
                        101,
                        NULL,
                        1,
                        "*:*", "");

  CCTKi_ParameterCreate("print_timing_stats",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we print timing stats for the whole apparent-horizon-finding process?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.print_timing_stats),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("run_at_CCTK_ANALYSIS",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "should we run at CCTK_ANALYSIS?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.run_at_CCTK_ANALYSIS),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("run_at_CCTK_POSTINITIAL",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "should we run at CCTK_POSTINITIAL?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.run_at_CCTK_POSTINITIAL),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("run_at_CCTK_POSTSTEP",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_NEVER,
                        "should we run at CCTK_POSTSTEP?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.run_at_CCTK_POSTSTEP),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("run_at_CCTK_POST_RECOVER_VARIABLES",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_ALWAYS,
                        "should we run at CCTK_POST_RECOVER_VARIABLES?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.run_at_CCTK_POST_RECOVER_VARIABLES),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("set_mask_for_all_horizons",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we set a mask grid function (or functions) for all horizons?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.set_mask_for_all_horizons),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("set_mask_for_individual_horizon",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we set a mask grid function (or functions) for *this* horizon?",
                        "false",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.set_mask_for_individual_horizon),
                        101,
                        NULL,
                        0);

  CCTKi_ParameterCreate("set_new_style_mask",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "if we're setting a mask, should we set an new-style (CCTK_INT) mask gridfn?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.set_new_style_mask),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("set_old_style_mask",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "if we're setting a mask, should we set an old-style (CCTK_REAL) mask gridfn?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.set_old_style_mask),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("shiftout_factor",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "enlarge the surface initial guess before finding",
                        "1.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.shiftout_factor),
                        101,
                        NULL,
                        1,
                        "(0:*", "choose 1 for doing nothing, larger for enlarging, smaller for shrinking");

  CCTKi_ParameterCreate("smoothing_factor",
                        "ahfinderdirect",
                        "REAL",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "smoothen (remove higher multipole moments) the surface initial guess before finding",
                        "0.0",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.smoothing_factor),
                        101,
                        NULL,
                        1,
                        "*:*", "choose 0 for no smoothing, 1 for complete smoothing, larger for over-smoothing, negative for roughening");

  CCTKi_ParameterCreate("surface_definition",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "search for what kind of surface?",
                        "expansion",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.surface_definition),
                        101,
                        NULL,
                        4,
                        "expansion", "Theta_(l) (apparent horizons etc.)",
                        "inner expansion", "Theta_(n) (expansion of ingoing null normal)",
                        "mean curvature", "for CMC surfaces",
                        "expansion product", "Theta_(l) Theta_(n) (product of the expansions)");

  CCTKi_ParameterCreate("surface_interpolator_name",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "name under which the surface interpolation operator is registered in Cactus",
                        "Lagrange polynomial interpolation",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.surface_interpolator_name),
                        0,
                        NULL,
                        2,
                        "^$", "the empty string if this interpolator isn't going to be used",
                        ".+", "any string (in practice it should be nonempty)");

  CCTKi_ParameterCreate("surface_interpolator_pars",
                        "ahfinderdirect",
                        "STRING",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "parameters for the surface interpolator",
                        "order=2    boundary_off_centering_tolerance={1.0e-10 1.0e-10 1.0e-10 1.0e-10}    boundary_extrapolation_tolerance={0.0 0.0 0.0 0.0}",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.surface_interpolator_pars),
                        0,
                        NULL,
                        1,
                        ".*",   "any string acceptable to Util_TableSetFromString() and to the interpolator");

  CCTKi_ParameterCreate("surface_modification",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "how to modify the surface definition",
                        "none",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.surface_modification),
                        101,
                        NULL,
                        5,
                        "none", "no modification",
                        "radius", "multiply with the coordinate radius",
                        "radius^2", "multiply with the square of the coordinate radius",
                        "mean radius", "multiply with the mean coordinate radius",
                        "areal radius", "multiply with the areal radius (does not converge nicely, because the Jacobian is only approximate)");

  CCTKi_ParameterCreate("surface_selection",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "search for a surface with this areal radius",
                        "definition",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.surface_selection),
                        101,
                        NULL,
                        5,
                        "definition", "look for a surface as defined by 'surface_definition'",
                        "mean coordinate radius", "look for a surface with a certain mean coordinate radius (not covariant, but fast)",
                        "areal radius", "look for a surface with a certain areal radius",
                        "expansion times mean coordinate radius", "look for a surface with a certain product of expansion and mean coordiante radius",
                        "expansion times areal radius", "look for a surface with a certain product of expansion and areal radius");

  CCTKi_ParameterCreate("test_all_Jacobian_compute_methods",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we test all Jacobian computation methods, or just NP?",
                        "true",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.test_all_Jacobian_compute_methods),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("use_pretracking",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "search for an outermost apparent horizon",
                        "no",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.use_pretracking),
                        101,
                        NULL,
                        0);

  CCTKi_ParameterCreate("verbose_level",
                        "ahfinderdirect",
                        "KEYWORD",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "controls which (how many) messages to print describing AH finding",
                        "physics details",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.verbose_level),
                        0,
                        NULL,
                        5,
                        "physics highlights", "just a few physics messages",
                        "physics details", "more detailed physics messages",
                        "algorithm highlights",   "physics details + a few messages about the AH-finding algorithm",
                        "algorithm details",   "physics details + lots of messages about the AH-finding algorithm",
                        "algorithm debug",   "physics details + lots and lots of messages about the AH-finding algorithm");

  CCTKi_ParameterCreate("want_expansion_gradients",
                        "ahfinderdirect",
                        "BOOLEAN",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "should we print the gradients of the expansions?",
                        "false",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.want_expansion_gradients),
                        0,
                        NULL,
                        0);

  CCTKi_ParameterCreate("warn_level__gij_not_positive_definite__initial",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "warning level if the interpolated g_{ij} isn't positive definite    (usually this means we're too close to a singularity)    (error occurs on first Newton iteration)",
                        "2",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.warn_level__gij_not_positive_definite__initial),
                        0,
                        NULL,
                        1,
                        "-1:*", "any valid Cactus warning level");

  CCTKi_ParameterCreate("warn_level__gij_not_positive_definite__subsequent",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "warning level if the interpolated g_{ij} isn't positive definite    (usually this means we're too close to a singularity)    (error occurs on subsequent Newton iteration)",
                        "2",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.warn_level__gij_not_positive_definite__subsequent),
                        0,
                        NULL,
                        1,
                        "-1:*", "any valid Cactus warning level");

  CCTKi_ParameterCreate("warn_level__nonfinite_geometry",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "warning level if we find infinity and/or NaN in the interpolated geometry    values {g_ij, partial_k g_ij, K_ij}",
                        "1",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.warn_level__nonfinite_geometry),
                        0,
                        NULL,
                        1,
                        "-1:*", "any valid Cactus warning level");

  CCTKi_ParameterCreate("warn_level__point_outside__initial",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "warning level for point outside (or too close to boundary of) Cactus grid    (error occurs on first Newton iteration)",
                        "1",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.warn_level__point_outside__initial),
                        0,
                        NULL,
                        1,
                        "-1:*", "any valid Cactus warning level");

  CCTKi_ParameterCreate("warn_level__point_outside__subsequent",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "warning level for point outside (or too close to boundary of) Cactus grid    (error occurs on subsequent Newton iteration)",
                        "2",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.warn_level__point_outside__subsequent),
                        0,
                        NULL,
                        1,
                        "-1:*", "any valid Cactus warning level");

  CCTKi_ParameterCreate("warn_level__skipping_finite_check",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "warning level if the user sets  check_that_geometry_is_finite    but the Cactus configure process doesn't find a  finite()  function    so we have to skip the finite-geometry check",
                        "3",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.warn_level__skipping_finite_check),
                        0,
                        NULL,
                        1,
                        "-1:*", "any valid Cactus warning level");

  CCTKi_ParameterCreate("which_horizon_to_announce_centroid",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "for which horizon should we announce the centroid?",
                        "0",
                        &(PRIVATE_AHFINDERDIRECT_STRUCT.which_horizon_to_announce_centroid),
                        0,
                        NULL,
                        2,
                        "0", "don't announce any centroid(s)",
                        "1:100", "announce this horizon's centroid each time we find it");

  CCTKi_ParameterCreate("which_surface_to_store_info",
                        "ahfinderdirect",
                        "INT",
                        "PRIVATE",
                        CCTK_STEERABLE_RECOVER,
                        "into which surface should we store the info?",
                        "-1",
                        (PRIVATE_AHFINDERDIRECT_STRUCT.which_surface_to_store_info),
                        101,
                        NULL,
                        2,
                        "-1", "don't store info",
                        "0:*", "store info into the corresponding surface");

  return 0;
}

int CCTKi_BindingsahfinderdirectParameterExtensions(void);
int CCTKi_BindingsahfinderdirectParameterExtensions(void)
{
  return 0;
}

